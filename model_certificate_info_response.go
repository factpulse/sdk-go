/*
FactPulse REST API

 REST API for electronic invoicing in France: Factur-X, AFNOR PDP/PA, electronic signatures.  ## üéØ Main Features  ### üìÑ Factur-X Invoice Generation - **Formats**: XML only or PDF/A-3 with embedded XML - **Profiles**: MINIMUM, BASIC, EN16931, EXTENDED - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **üÜï Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### ‚úÖ Validation and Compliance - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata, electronic signatures - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules) - **Asynchronous Processing**: Celery support for heavy validations (VeraPDF)  ### üì° AFNOR PDP/PA Integration (XP Z12-013) - **Flow Submission**: Send invoices to Partner Dematerialization Platforms - **Flow Search**: View submitted invoices - **Download**: Retrieve PDF/A-3 with XML - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user (stored credentials or zero-storage)  ### ‚úçÔ∏è PDF Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification - **Certificate Generation**: Self-signed X.509 certificates for testing  ### üîÑ Asynchronous Processing - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **No timeout**: Ideal for large files or heavy validations  ## üîí Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### üîë Method 1: `/api/token/` API (Recommended)  **URL:** `https://factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - ‚úÖ Full automation (CI/CD, scripts) - ‚úÖ Programmatic token management - ‚úÖ Refresh token support for automatic access renewal - ‚úÖ Easy integration in any language/tool  #### üñ•Ô∏è Method 2: Dashboard Generation (Alternative)  **URL:** https://factpulse.fr/api/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - ‚úÖ Quick for API testing - ‚úÖ No password required - ‚úÖ Simple visual interface  **Disadvantages:** - ‚ùå Requires manual action - ‚ùå No refresh token - ‚ùå Less suited for automation  ### üìö Full Documentation  For more information on authentication and API usage: https://factpulse.fr/documentation-api/     

API version: 1.0.0
Contact: contact@factpulse.fr
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github.com/factpulse/sdk-go/v3

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the CertificateInfoResponse type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &CertificateInfoResponse{}

// CertificateInfoResponse Information about a generated certificate.
type CertificateInfoResponse struct {
	// Common Name
	Cn string `json:"cn"`
	// Organization
	Organization string `json:"organization"`
	// Country code
	Country string `json:"country"`
	// City
	City string `json:"city"`
	// State/Province
	State string `json:"state"`
	Email NullableString `json:"email,omitempty"`
	// Full subject (RFC4514)
	Subject string `json:"subject"`
	// Issuer (self-signed = same as subject)
	Issuer string `json:"issuer"`
	// Certificate serial number
	SerialNumber int32 `json:"serialNumber"`
	// Validity start date (ISO 8601)
	ValidFrom string `json:"validFrom"`
	// Validity end date (ISO 8601)
	ValidTo string `json:"validTo"`
	// Signature algorithm
	Algorithm string `json:"algorithm"`
}

type _CertificateInfoResponse CertificateInfoResponse

// NewCertificateInfoResponse instantiates a new CertificateInfoResponse object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewCertificateInfoResponse(cn string, organization string, country string, city string, state string, subject string, issuer string, serialNumber int32, validFrom string, validTo string, algorithm string) *CertificateInfoResponse {
	this := CertificateInfoResponse{}
	this.Cn = cn
	this.Organization = organization
	this.Country = country
	this.City = city
	this.State = state
	this.Subject = subject
	this.Issuer = issuer
	this.SerialNumber = serialNumber
	this.ValidFrom = validFrom
	this.ValidTo = validTo
	this.Algorithm = algorithm
	return &this
}

// NewCertificateInfoResponseWithDefaults instantiates a new CertificateInfoResponse object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewCertificateInfoResponseWithDefaults() *CertificateInfoResponse {
	this := CertificateInfoResponse{}
	return &this
}

// GetCn returns the Cn field value
func (o *CertificateInfoResponse) GetCn() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Cn
}

// GetCnOk returns a tuple with the Cn field value
// and a boolean to check if the value has been set.
func (o *CertificateInfoResponse) GetCnOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Cn, true
}

// SetCn sets field value
func (o *CertificateInfoResponse) SetCn(v string) {
	o.Cn = v
}

// GetOrganization returns the Organization field value
func (o *CertificateInfoResponse) GetOrganization() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Organization
}

// GetOrganizationOk returns a tuple with the Organization field value
// and a boolean to check if the value has been set.
func (o *CertificateInfoResponse) GetOrganizationOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Organization, true
}

// SetOrganization sets field value
func (o *CertificateInfoResponse) SetOrganization(v string) {
	o.Organization = v
}

// GetCountry returns the Country field value
func (o *CertificateInfoResponse) GetCountry() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Country
}

// GetCountryOk returns a tuple with the Country field value
// and a boolean to check if the value has been set.
func (o *CertificateInfoResponse) GetCountryOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Country, true
}

// SetCountry sets field value
func (o *CertificateInfoResponse) SetCountry(v string) {
	o.Country = v
}

// GetCity returns the City field value
func (o *CertificateInfoResponse) GetCity() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.City
}

// GetCityOk returns a tuple with the City field value
// and a boolean to check if the value has been set.
func (o *CertificateInfoResponse) GetCityOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.City, true
}

// SetCity sets field value
func (o *CertificateInfoResponse) SetCity(v string) {
	o.City = v
}

// GetState returns the State field value
func (o *CertificateInfoResponse) GetState() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.State
}

// GetStateOk returns a tuple with the State field value
// and a boolean to check if the value has been set.
func (o *CertificateInfoResponse) GetStateOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.State, true
}

// SetState sets field value
func (o *CertificateInfoResponse) SetState(v string) {
	o.State = v
}

// GetEmail returns the Email field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *CertificateInfoResponse) GetEmail() string {
	if o == nil || IsNil(o.Email.Get()) {
		var ret string
		return ret
	}
	return *o.Email.Get()
}

// GetEmailOk returns a tuple with the Email field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *CertificateInfoResponse) GetEmailOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Email.Get(), o.Email.IsSet()
}

// HasEmail returns a boolean if a field has been set.
func (o *CertificateInfoResponse) HasEmail() bool {
	if o != nil && o.Email.IsSet() {
		return true
	}

	return false
}

// SetEmail gets a reference to the given NullableString and assigns it to the Email field.
func (o *CertificateInfoResponse) SetEmail(v string) {
	o.Email.Set(&v)
}
// SetEmailNil sets the value for Email to be an explicit nil
func (o *CertificateInfoResponse) SetEmailNil() {
	o.Email.Set(nil)
}

// UnsetEmail ensures that no value is present for Email, not even an explicit nil
func (o *CertificateInfoResponse) UnsetEmail() {
	o.Email.Unset()
}

// GetSubject returns the Subject field value
func (o *CertificateInfoResponse) GetSubject() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Subject
}

// GetSubjectOk returns a tuple with the Subject field value
// and a boolean to check if the value has been set.
func (o *CertificateInfoResponse) GetSubjectOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Subject, true
}

// SetSubject sets field value
func (o *CertificateInfoResponse) SetSubject(v string) {
	o.Subject = v
}

// GetIssuer returns the Issuer field value
func (o *CertificateInfoResponse) GetIssuer() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Issuer
}

// GetIssuerOk returns a tuple with the Issuer field value
// and a boolean to check if the value has been set.
func (o *CertificateInfoResponse) GetIssuerOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Issuer, true
}

// SetIssuer sets field value
func (o *CertificateInfoResponse) SetIssuer(v string) {
	o.Issuer = v
}

// GetSerialNumber returns the SerialNumber field value
func (o *CertificateInfoResponse) GetSerialNumber() int32 {
	if o == nil {
		var ret int32
		return ret
	}

	return o.SerialNumber
}

// GetSerialNumberOk returns a tuple with the SerialNumber field value
// and a boolean to check if the value has been set.
func (o *CertificateInfoResponse) GetSerialNumberOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return &o.SerialNumber, true
}

// SetSerialNumber sets field value
func (o *CertificateInfoResponse) SetSerialNumber(v int32) {
	o.SerialNumber = v
}

// GetValidFrom returns the ValidFrom field value
func (o *CertificateInfoResponse) GetValidFrom() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ValidFrom
}

// GetValidFromOk returns a tuple with the ValidFrom field value
// and a boolean to check if the value has been set.
func (o *CertificateInfoResponse) GetValidFromOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ValidFrom, true
}

// SetValidFrom sets field value
func (o *CertificateInfoResponse) SetValidFrom(v string) {
	o.ValidFrom = v
}

// GetValidTo returns the ValidTo field value
func (o *CertificateInfoResponse) GetValidTo() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ValidTo
}

// GetValidToOk returns a tuple with the ValidTo field value
// and a boolean to check if the value has been set.
func (o *CertificateInfoResponse) GetValidToOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ValidTo, true
}

// SetValidTo sets field value
func (o *CertificateInfoResponse) SetValidTo(v string) {
	o.ValidTo = v
}

// GetAlgorithm returns the Algorithm field value
func (o *CertificateInfoResponse) GetAlgorithm() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Algorithm
}

// GetAlgorithmOk returns a tuple with the Algorithm field value
// and a boolean to check if the value has been set.
func (o *CertificateInfoResponse) GetAlgorithmOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Algorithm, true
}

// SetAlgorithm sets field value
func (o *CertificateInfoResponse) SetAlgorithm(v string) {
	o.Algorithm = v
}

func (o CertificateInfoResponse) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o CertificateInfoResponse) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["cn"] = o.Cn
	toSerialize["organization"] = o.Organization
	toSerialize["country"] = o.Country
	toSerialize["city"] = o.City
	toSerialize["state"] = o.State
	if o.Email.IsSet() {
		toSerialize["email"] = o.Email.Get()
	}
	toSerialize["subject"] = o.Subject
	toSerialize["issuer"] = o.Issuer
	toSerialize["serialNumber"] = o.SerialNumber
	toSerialize["validFrom"] = o.ValidFrom
	toSerialize["validTo"] = o.ValidTo
	toSerialize["algorithm"] = o.Algorithm
	return toSerialize, nil
}

func (o *CertificateInfoResponse) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"cn",
		"organization",
		"country",
		"city",
		"state",
		"subject",
		"issuer",
		"serialNumber",
		"validFrom",
		"validTo",
		"algorithm",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varCertificateInfoResponse := _CertificateInfoResponse{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varCertificateInfoResponse)

	if err != nil {
		return err
	}

	*o = CertificateInfoResponse(varCertificateInfoResponse)

	return err
}

type NullableCertificateInfoResponse struct {
	value *CertificateInfoResponse
	isSet bool
}

func (v NullableCertificateInfoResponse) Get() *CertificateInfoResponse {
	return v.value
}

func (v *NullableCertificateInfoResponse) Set(val *CertificateInfoResponse) {
	v.value = val
	v.isSet = true
}

func (v NullableCertificateInfoResponse) IsSet() bool {
	return v.isSet
}

func (v *NullableCertificateInfoResponse) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableCertificateInfoResponse(val *CertificateInfoResponse) *NullableCertificateInfoResponse {
	return &NullableCertificateInfoResponse{value: val, isSet: true}
}

func (v NullableCertificateInfoResponse) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableCertificateInfoResponse) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


