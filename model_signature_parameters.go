/*
FactPulse REST API

 REST API for electronic invoicing in France: Factur-X, AFNOR PDP/PA, electronic signatures.  ## üéØ Main Features  ### üìÑ Factur-X Invoice Generation - **Formats**: XML only or PDF/A-3 with embedded XML - **Profiles**: MINIMUM, BASIC, EN16931, EXTENDED - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **üÜï Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### ‚úÖ Validation and Compliance - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata, electronic signatures - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules) - **Asynchronous Processing**: Celery support for heavy validations (VeraPDF)  ### üì° AFNOR PDP/PA Integration (XP Z12-013) - **Flow Submission**: Send invoices to Partner Dematerialization Platforms - **Flow Search**: View submitted invoices - **Download**: Retrieve PDF/A-3 with XML - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user (stored credentials or zero-storage)  ### ‚úçÔ∏è PDF Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification - **Certificate Generation**: Self-signed X.509 certificates for testing  ### üîÑ Asynchronous Processing - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **No timeout**: Ideal for large files or heavy validations  ## üîí Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### üîë Method 1: `/api/token/` API (Recommended)  **URL:** `https://factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - ‚úÖ Full automation (CI/CD, scripts) - ‚úÖ Programmatic token management - ‚úÖ Refresh token support for automatic access renewal - ‚úÖ Easy integration in any language/tool  #### üñ•Ô∏è Method 2: Dashboard Generation (Alternative)  **URL:** https://factpulse.fr/api/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - ‚úÖ Quick for API testing - ‚úÖ No password required - ‚úÖ Simple visual interface  **Disadvantages:** - ‚ùå Requires manual action - ‚ùå No refresh token - ‚ùå Less suited for automation  ### üìö Full Documentation  For more information on authentication and API usage: https://factpulse.fr/documentation-api/     

API version: 1.0.0
Contact: contact@factpulse.fr
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github.com/factpulse/sdk-go/v3

import (
	"encoding/json"
)

// checks if the SignatureParameters type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &SignatureParameters{}

// SignatureParameters Optional parameters to sign the generated PDF.  **MODE 1 - Stored certificate (recommended):** Only provide metadata (reason, location, etc.). The certificate will be automatically retrieved via client_uid from JWT. eIDAS compliant PAdES-B-LT signature.  **MODE 2 - Keys in payload (tests/special cases):** Provide key_pem + cert_pem directly in the payload. Accepted PEM format: raw (\"-----BEGIN...\") or base64.  **Selection rule:** - If key_pem AND cert_pem provided ‚Üí Mode 2 (payload keys) - Otherwise ‚Üí Mode 1 (stored certificate retrieved via client_uid)
type SignatureParameters struct {
	KeyPem NullableString `json:"keyPem,omitempty"`
	CertPem NullableString `json:"certPem,omitempty"`
	KeyPassphrase NullableString `json:"keyPassphrase,omitempty"`
	Reason NullableString `json:"reason,omitempty"`
	Location NullableString `json:"location,omitempty"`
	Contact NullableString `json:"contact,omitempty"`
	// PDF signature field name
	FieldName *string `json:"fieldName,omitempty"`
	// Enable PAdES-B-LT (long-term archival). REQUIRES certificate with OCSP/CRL access
	UsePadesLt *bool `json:"usePadesLt,omitempty"`
	// Enable RFC 3161 timestamping with FreeTSA (PAdES-B-T)
	UseTimestamp *bool `json:"useTimestamp,omitempty"`
}

// NewSignatureParameters instantiates a new SignatureParameters object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewSignatureParameters() *SignatureParameters {
	this := SignatureParameters{}
	var fieldName string = "FactPulseSignature"
	this.FieldName = &fieldName
	var usePadesLt bool = false
	this.UsePadesLt = &usePadesLt
	var useTimestamp bool = true
	this.UseTimestamp = &useTimestamp
	return &this
}

// NewSignatureParametersWithDefaults instantiates a new SignatureParameters object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewSignatureParametersWithDefaults() *SignatureParameters {
	this := SignatureParameters{}
	var fieldName string = "FactPulseSignature"
	this.FieldName = &fieldName
	var usePadesLt bool = false
	this.UsePadesLt = &usePadesLt
	var useTimestamp bool = true
	this.UseTimestamp = &useTimestamp
	return &this
}

// GetKeyPem returns the KeyPem field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *SignatureParameters) GetKeyPem() string {
	if o == nil || IsNil(o.KeyPem.Get()) {
		var ret string
		return ret
	}
	return *o.KeyPem.Get()
}

// GetKeyPemOk returns a tuple with the KeyPem field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *SignatureParameters) GetKeyPemOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.KeyPem.Get(), o.KeyPem.IsSet()
}

// HasKeyPem returns a boolean if a field has been set.
func (o *SignatureParameters) HasKeyPem() bool {
	if o != nil && o.KeyPem.IsSet() {
		return true
	}

	return false
}

// SetKeyPem gets a reference to the given NullableString and assigns it to the KeyPem field.
func (o *SignatureParameters) SetKeyPem(v string) {
	o.KeyPem.Set(&v)
}
// SetKeyPemNil sets the value for KeyPem to be an explicit nil
func (o *SignatureParameters) SetKeyPemNil() {
	o.KeyPem.Set(nil)
}

// UnsetKeyPem ensures that no value is present for KeyPem, not even an explicit nil
func (o *SignatureParameters) UnsetKeyPem() {
	o.KeyPem.Unset()
}

// GetCertPem returns the CertPem field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *SignatureParameters) GetCertPem() string {
	if o == nil || IsNil(o.CertPem.Get()) {
		var ret string
		return ret
	}
	return *o.CertPem.Get()
}

// GetCertPemOk returns a tuple with the CertPem field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *SignatureParameters) GetCertPemOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.CertPem.Get(), o.CertPem.IsSet()
}

// HasCertPem returns a boolean if a field has been set.
func (o *SignatureParameters) HasCertPem() bool {
	if o != nil && o.CertPem.IsSet() {
		return true
	}

	return false
}

// SetCertPem gets a reference to the given NullableString and assigns it to the CertPem field.
func (o *SignatureParameters) SetCertPem(v string) {
	o.CertPem.Set(&v)
}
// SetCertPemNil sets the value for CertPem to be an explicit nil
func (o *SignatureParameters) SetCertPemNil() {
	o.CertPem.Set(nil)
}

// UnsetCertPem ensures that no value is present for CertPem, not even an explicit nil
func (o *SignatureParameters) UnsetCertPem() {
	o.CertPem.Unset()
}

// GetKeyPassphrase returns the KeyPassphrase field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *SignatureParameters) GetKeyPassphrase() string {
	if o == nil || IsNil(o.KeyPassphrase.Get()) {
		var ret string
		return ret
	}
	return *o.KeyPassphrase.Get()
}

// GetKeyPassphraseOk returns a tuple with the KeyPassphrase field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *SignatureParameters) GetKeyPassphraseOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.KeyPassphrase.Get(), o.KeyPassphrase.IsSet()
}

// HasKeyPassphrase returns a boolean if a field has been set.
func (o *SignatureParameters) HasKeyPassphrase() bool {
	if o != nil && o.KeyPassphrase.IsSet() {
		return true
	}

	return false
}

// SetKeyPassphrase gets a reference to the given NullableString and assigns it to the KeyPassphrase field.
func (o *SignatureParameters) SetKeyPassphrase(v string) {
	o.KeyPassphrase.Set(&v)
}
// SetKeyPassphraseNil sets the value for KeyPassphrase to be an explicit nil
func (o *SignatureParameters) SetKeyPassphraseNil() {
	o.KeyPassphrase.Set(nil)
}

// UnsetKeyPassphrase ensures that no value is present for KeyPassphrase, not even an explicit nil
func (o *SignatureParameters) UnsetKeyPassphrase() {
	o.KeyPassphrase.Unset()
}

// GetReason returns the Reason field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *SignatureParameters) GetReason() string {
	if o == nil || IsNil(o.Reason.Get()) {
		var ret string
		return ret
	}
	return *o.Reason.Get()
}

// GetReasonOk returns a tuple with the Reason field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *SignatureParameters) GetReasonOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Reason.Get(), o.Reason.IsSet()
}

// HasReason returns a boolean if a field has been set.
func (o *SignatureParameters) HasReason() bool {
	if o != nil && o.Reason.IsSet() {
		return true
	}

	return false
}

// SetReason gets a reference to the given NullableString and assigns it to the Reason field.
func (o *SignatureParameters) SetReason(v string) {
	o.Reason.Set(&v)
}
// SetReasonNil sets the value for Reason to be an explicit nil
func (o *SignatureParameters) SetReasonNil() {
	o.Reason.Set(nil)
}

// UnsetReason ensures that no value is present for Reason, not even an explicit nil
func (o *SignatureParameters) UnsetReason() {
	o.Reason.Unset()
}

// GetLocation returns the Location field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *SignatureParameters) GetLocation() string {
	if o == nil || IsNil(o.Location.Get()) {
		var ret string
		return ret
	}
	return *o.Location.Get()
}

// GetLocationOk returns a tuple with the Location field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *SignatureParameters) GetLocationOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Location.Get(), o.Location.IsSet()
}

// HasLocation returns a boolean if a field has been set.
func (o *SignatureParameters) HasLocation() bool {
	if o != nil && o.Location.IsSet() {
		return true
	}

	return false
}

// SetLocation gets a reference to the given NullableString and assigns it to the Location field.
func (o *SignatureParameters) SetLocation(v string) {
	o.Location.Set(&v)
}
// SetLocationNil sets the value for Location to be an explicit nil
func (o *SignatureParameters) SetLocationNil() {
	o.Location.Set(nil)
}

// UnsetLocation ensures that no value is present for Location, not even an explicit nil
func (o *SignatureParameters) UnsetLocation() {
	o.Location.Unset()
}

// GetContact returns the Contact field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *SignatureParameters) GetContact() string {
	if o == nil || IsNil(o.Contact.Get()) {
		var ret string
		return ret
	}
	return *o.Contact.Get()
}

// GetContactOk returns a tuple with the Contact field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *SignatureParameters) GetContactOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Contact.Get(), o.Contact.IsSet()
}

// HasContact returns a boolean if a field has been set.
func (o *SignatureParameters) HasContact() bool {
	if o != nil && o.Contact.IsSet() {
		return true
	}

	return false
}

// SetContact gets a reference to the given NullableString and assigns it to the Contact field.
func (o *SignatureParameters) SetContact(v string) {
	o.Contact.Set(&v)
}
// SetContactNil sets the value for Contact to be an explicit nil
func (o *SignatureParameters) SetContactNil() {
	o.Contact.Set(nil)
}

// UnsetContact ensures that no value is present for Contact, not even an explicit nil
func (o *SignatureParameters) UnsetContact() {
	o.Contact.Unset()
}

// GetFieldName returns the FieldName field value if set, zero value otherwise.
func (o *SignatureParameters) GetFieldName() string {
	if o == nil || IsNil(o.FieldName) {
		var ret string
		return ret
	}
	return *o.FieldName
}

// GetFieldNameOk returns a tuple with the FieldName field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SignatureParameters) GetFieldNameOk() (*string, bool) {
	if o == nil || IsNil(o.FieldName) {
		return nil, false
	}
	return o.FieldName, true
}

// HasFieldName returns a boolean if a field has been set.
func (o *SignatureParameters) HasFieldName() bool {
	if o != nil && !IsNil(o.FieldName) {
		return true
	}

	return false
}

// SetFieldName gets a reference to the given string and assigns it to the FieldName field.
func (o *SignatureParameters) SetFieldName(v string) {
	o.FieldName = &v
}

// GetUsePadesLt returns the UsePadesLt field value if set, zero value otherwise.
func (o *SignatureParameters) GetUsePadesLt() bool {
	if o == nil || IsNil(o.UsePadesLt) {
		var ret bool
		return ret
	}
	return *o.UsePadesLt
}

// GetUsePadesLtOk returns a tuple with the UsePadesLt field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SignatureParameters) GetUsePadesLtOk() (*bool, bool) {
	if o == nil || IsNil(o.UsePadesLt) {
		return nil, false
	}
	return o.UsePadesLt, true
}

// HasUsePadesLt returns a boolean if a field has been set.
func (o *SignatureParameters) HasUsePadesLt() bool {
	if o != nil && !IsNil(o.UsePadesLt) {
		return true
	}

	return false
}

// SetUsePadesLt gets a reference to the given bool and assigns it to the UsePadesLt field.
func (o *SignatureParameters) SetUsePadesLt(v bool) {
	o.UsePadesLt = &v
}

// GetUseTimestamp returns the UseTimestamp field value if set, zero value otherwise.
func (o *SignatureParameters) GetUseTimestamp() bool {
	if o == nil || IsNil(o.UseTimestamp) {
		var ret bool
		return ret
	}
	return *o.UseTimestamp
}

// GetUseTimestampOk returns a tuple with the UseTimestamp field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SignatureParameters) GetUseTimestampOk() (*bool, bool) {
	if o == nil || IsNil(o.UseTimestamp) {
		return nil, false
	}
	return o.UseTimestamp, true
}

// HasUseTimestamp returns a boolean if a field has been set.
func (o *SignatureParameters) HasUseTimestamp() bool {
	if o != nil && !IsNil(o.UseTimestamp) {
		return true
	}

	return false
}

// SetUseTimestamp gets a reference to the given bool and assigns it to the UseTimestamp field.
func (o *SignatureParameters) SetUseTimestamp(v bool) {
	o.UseTimestamp = &v
}

func (o SignatureParameters) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o SignatureParameters) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if o.KeyPem.IsSet() {
		toSerialize["keyPem"] = o.KeyPem.Get()
	}
	if o.CertPem.IsSet() {
		toSerialize["certPem"] = o.CertPem.Get()
	}
	if o.KeyPassphrase.IsSet() {
		toSerialize["keyPassphrase"] = o.KeyPassphrase.Get()
	}
	if o.Reason.IsSet() {
		toSerialize["reason"] = o.Reason.Get()
	}
	if o.Location.IsSet() {
		toSerialize["location"] = o.Location.Get()
	}
	if o.Contact.IsSet() {
		toSerialize["contact"] = o.Contact.Get()
	}
	if !IsNil(o.FieldName) {
		toSerialize["fieldName"] = o.FieldName
	}
	if !IsNil(o.UsePadesLt) {
		toSerialize["usePadesLt"] = o.UsePadesLt
	}
	if !IsNil(o.UseTimestamp) {
		toSerialize["useTimestamp"] = o.UseTimestamp
	}
	return toSerialize, nil
}

type NullableSignatureParameters struct {
	value *SignatureParameters
	isSet bool
}

func (v NullableSignatureParameters) Get() *SignatureParameters {
	return v.value
}

func (v *NullableSignatureParameters) Set(val *SignatureParameters) {
	v.value = val
	v.isSet = true
}

func (v NullableSignatureParameters) IsSet() bool {
	return v.isSet
}

func (v *NullableSignatureParameters) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableSignatureParameters(val *SignatureParameters) *NullableSignatureParameters {
	return &NullableSignatureParameters{value: val, isSet: true}
}

func (v NullableSignatureParameters) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableSignatureParameters) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


