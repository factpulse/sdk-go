/*
FactPulse REST API

 REST API for electronic invoicing in France: Factur-X, AFNOR PDP/PA, electronic signatures.  ## üéØ Main Features  ### üìÑ Factur-X Invoice Generation - **Formats**: XML only or PDF/A-3 with embedded XML - **Profiles**: MINIMUM, BASIC, EN16931, EXTENDED - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **üÜï Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### ‚úÖ Validation and Compliance - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata, electronic signatures - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules) - **Asynchronous Processing**: Celery support for heavy validations (VeraPDF)  ### üì° AFNOR PDP/PA Integration (XP Z12-013) - **Flow Submission**: Send invoices to Partner Dematerialization Platforms - **Flow Search**: View submitted invoices - **Download**: Retrieve PDF/A-3 with XML - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user (stored credentials or zero-storage)  ### ‚úçÔ∏è PDF Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification - **Certificate Generation**: Self-signed X.509 certificates for testing  ### üîÑ Asynchronous Processing - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **No timeout**: Ideal for large files or heavy validations  ## üîí Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### üîë Method 1: `/api/token/` API (Recommended)  **URL:** `https://factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - ‚úÖ Full automation (CI/CD, scripts) - ‚úÖ Programmatic token management - ‚úÖ Refresh token support for automatic access renewal - ‚úÖ Easy integration in any language/tool  #### üñ•Ô∏è Method 2: Dashboard Generation (Alternative)  **URL:** https://factpulse.fr/api/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - ‚úÖ Quick for API testing - ‚úÖ No password required - ‚úÖ Simple visual interface  **Disadvantages:** - ‚ùå Requires manual action - ‚ùå No refresh token - ‚ùå Less suited for automation  ### üìö Full Documentation  For more information on authentication and API usage: https://factpulse.fr/documentation-api/     

API version: 1.0.0
Contact: contact@factpulse.fr
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github.com/factpulse/sdk-go/v3

import (
	"encoding/json"
)

// checks if the GenerateCertificateRequest type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &GenerateCertificateRequest{}

// GenerateCertificateRequest Request to generate a self-signed X.509 test certificate.  WARNING: This certificate is intended for TESTING only. DO NOT use in production! eIDAS level: SES (Simple Electronic Signature)
type GenerateCertificateRequest struct {
	// Common Name (CN) - Certificate name
	Cn *string `json:"cn,omitempty"`
	// Organization (O)
	Organization *string `json:"organization,omitempty"`
	// ISO 2-letter country code (C)
	Country *string `json:"country,omitempty"`
	// City (L)
	City *string `json:"city,omitempty"`
	// State/Province (ST)
	State *string `json:"state,omitempty"`
	Email NullableString `json:"email,omitempty"`
	// Validity duration in days
	ValidityDays *int32 `json:"validityDays,omitempty"`
	// RSA key size in bits
	KeySize *int32 `json:"keySize,omitempty"`
	KeyPassphrase NullableString `json:"keyPassphrase,omitempty"`
	// Also generate a PKCS#12 (.p12) file
	GenerateP12 *bool `json:"generateP12,omitempty"`
	// Passphrase for PKCS#12 file
	P12Passphrase *string `json:"p12Passphrase,omitempty"`
}

// NewGenerateCertificateRequest instantiates a new GenerateCertificateRequest object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewGenerateCertificateRequest() *GenerateCertificateRequest {
	this := GenerateCertificateRequest{}
	var cn string = "Test Signature FactPulse"
	this.Cn = &cn
	var organization string = "FactPulse Test"
	this.Organization = &organization
	var country string = "FR"
	this.Country = &country
	var city string = "Paris"
	this.City = &city
	var state string = "Ile-de-France"
	this.State = &state
	var validityDays int32 = 365
	this.ValidityDays = &validityDays
	var keySize int32 = 2048
	this.KeySize = &keySize
	var generateP12 bool = false
	this.GenerateP12 = &generateP12
	var p12Passphrase string = "changeme"
	this.P12Passphrase = &p12Passphrase
	return &this
}

// NewGenerateCertificateRequestWithDefaults instantiates a new GenerateCertificateRequest object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewGenerateCertificateRequestWithDefaults() *GenerateCertificateRequest {
	this := GenerateCertificateRequest{}
	var cn string = "Test Signature FactPulse"
	this.Cn = &cn
	var organization string = "FactPulse Test"
	this.Organization = &organization
	var country string = "FR"
	this.Country = &country
	var city string = "Paris"
	this.City = &city
	var state string = "Ile-de-France"
	this.State = &state
	var validityDays int32 = 365
	this.ValidityDays = &validityDays
	var keySize int32 = 2048
	this.KeySize = &keySize
	var generateP12 bool = false
	this.GenerateP12 = &generateP12
	var p12Passphrase string = "changeme"
	this.P12Passphrase = &p12Passphrase
	return &this
}

// GetCn returns the Cn field value if set, zero value otherwise.
func (o *GenerateCertificateRequest) GetCn() string {
	if o == nil || IsNil(o.Cn) {
		var ret string
		return ret
	}
	return *o.Cn
}

// GetCnOk returns a tuple with the Cn field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GenerateCertificateRequest) GetCnOk() (*string, bool) {
	if o == nil || IsNil(o.Cn) {
		return nil, false
	}
	return o.Cn, true
}

// HasCn returns a boolean if a field has been set.
func (o *GenerateCertificateRequest) HasCn() bool {
	if o != nil && !IsNil(o.Cn) {
		return true
	}

	return false
}

// SetCn gets a reference to the given string and assigns it to the Cn field.
func (o *GenerateCertificateRequest) SetCn(v string) {
	o.Cn = &v
}

// GetOrganization returns the Organization field value if set, zero value otherwise.
func (o *GenerateCertificateRequest) GetOrganization() string {
	if o == nil || IsNil(o.Organization) {
		var ret string
		return ret
	}
	return *o.Organization
}

// GetOrganizationOk returns a tuple with the Organization field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GenerateCertificateRequest) GetOrganizationOk() (*string, bool) {
	if o == nil || IsNil(o.Organization) {
		return nil, false
	}
	return o.Organization, true
}

// HasOrganization returns a boolean if a field has been set.
func (o *GenerateCertificateRequest) HasOrganization() bool {
	if o != nil && !IsNil(o.Organization) {
		return true
	}

	return false
}

// SetOrganization gets a reference to the given string and assigns it to the Organization field.
func (o *GenerateCertificateRequest) SetOrganization(v string) {
	o.Organization = &v
}

// GetCountry returns the Country field value if set, zero value otherwise.
func (o *GenerateCertificateRequest) GetCountry() string {
	if o == nil || IsNil(o.Country) {
		var ret string
		return ret
	}
	return *o.Country
}

// GetCountryOk returns a tuple with the Country field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GenerateCertificateRequest) GetCountryOk() (*string, bool) {
	if o == nil || IsNil(o.Country) {
		return nil, false
	}
	return o.Country, true
}

// HasCountry returns a boolean if a field has been set.
func (o *GenerateCertificateRequest) HasCountry() bool {
	if o != nil && !IsNil(o.Country) {
		return true
	}

	return false
}

// SetCountry gets a reference to the given string and assigns it to the Country field.
func (o *GenerateCertificateRequest) SetCountry(v string) {
	o.Country = &v
}

// GetCity returns the City field value if set, zero value otherwise.
func (o *GenerateCertificateRequest) GetCity() string {
	if o == nil || IsNil(o.City) {
		var ret string
		return ret
	}
	return *o.City
}

// GetCityOk returns a tuple with the City field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GenerateCertificateRequest) GetCityOk() (*string, bool) {
	if o == nil || IsNil(o.City) {
		return nil, false
	}
	return o.City, true
}

// HasCity returns a boolean if a field has been set.
func (o *GenerateCertificateRequest) HasCity() bool {
	if o != nil && !IsNil(o.City) {
		return true
	}

	return false
}

// SetCity gets a reference to the given string and assigns it to the City field.
func (o *GenerateCertificateRequest) SetCity(v string) {
	o.City = &v
}

// GetState returns the State field value if set, zero value otherwise.
func (o *GenerateCertificateRequest) GetState() string {
	if o == nil || IsNil(o.State) {
		var ret string
		return ret
	}
	return *o.State
}

// GetStateOk returns a tuple with the State field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GenerateCertificateRequest) GetStateOk() (*string, bool) {
	if o == nil || IsNil(o.State) {
		return nil, false
	}
	return o.State, true
}

// HasState returns a boolean if a field has been set.
func (o *GenerateCertificateRequest) HasState() bool {
	if o != nil && !IsNil(o.State) {
		return true
	}

	return false
}

// SetState gets a reference to the given string and assigns it to the State field.
func (o *GenerateCertificateRequest) SetState(v string) {
	o.State = &v
}

// GetEmail returns the Email field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *GenerateCertificateRequest) GetEmail() string {
	if o == nil || IsNil(o.Email.Get()) {
		var ret string
		return ret
	}
	return *o.Email.Get()
}

// GetEmailOk returns a tuple with the Email field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *GenerateCertificateRequest) GetEmailOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.Email.Get(), o.Email.IsSet()
}

// HasEmail returns a boolean if a field has been set.
func (o *GenerateCertificateRequest) HasEmail() bool {
	if o != nil && o.Email.IsSet() {
		return true
	}

	return false
}

// SetEmail gets a reference to the given NullableString and assigns it to the Email field.
func (o *GenerateCertificateRequest) SetEmail(v string) {
	o.Email.Set(&v)
}
// SetEmailNil sets the value for Email to be an explicit nil
func (o *GenerateCertificateRequest) SetEmailNil() {
	o.Email.Set(nil)
}

// UnsetEmail ensures that no value is present for Email, not even an explicit nil
func (o *GenerateCertificateRequest) UnsetEmail() {
	o.Email.Unset()
}

// GetValidityDays returns the ValidityDays field value if set, zero value otherwise.
func (o *GenerateCertificateRequest) GetValidityDays() int32 {
	if o == nil || IsNil(o.ValidityDays) {
		var ret int32
		return ret
	}
	return *o.ValidityDays
}

// GetValidityDaysOk returns a tuple with the ValidityDays field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GenerateCertificateRequest) GetValidityDaysOk() (*int32, bool) {
	if o == nil || IsNil(o.ValidityDays) {
		return nil, false
	}
	return o.ValidityDays, true
}

// HasValidityDays returns a boolean if a field has been set.
func (o *GenerateCertificateRequest) HasValidityDays() bool {
	if o != nil && !IsNil(o.ValidityDays) {
		return true
	}

	return false
}

// SetValidityDays gets a reference to the given int32 and assigns it to the ValidityDays field.
func (o *GenerateCertificateRequest) SetValidityDays(v int32) {
	o.ValidityDays = &v
}

// GetKeySize returns the KeySize field value if set, zero value otherwise.
func (o *GenerateCertificateRequest) GetKeySize() int32 {
	if o == nil || IsNil(o.KeySize) {
		var ret int32
		return ret
	}
	return *o.KeySize
}

// GetKeySizeOk returns a tuple with the KeySize field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GenerateCertificateRequest) GetKeySizeOk() (*int32, bool) {
	if o == nil || IsNil(o.KeySize) {
		return nil, false
	}
	return o.KeySize, true
}

// HasKeySize returns a boolean if a field has been set.
func (o *GenerateCertificateRequest) HasKeySize() bool {
	if o != nil && !IsNil(o.KeySize) {
		return true
	}

	return false
}

// SetKeySize gets a reference to the given int32 and assigns it to the KeySize field.
func (o *GenerateCertificateRequest) SetKeySize(v int32) {
	o.KeySize = &v
}

// GetKeyPassphrase returns the KeyPassphrase field value if set, zero value otherwise (both if not set or set to explicit null).
func (o *GenerateCertificateRequest) GetKeyPassphrase() string {
	if o == nil || IsNil(o.KeyPassphrase.Get()) {
		var ret string
		return ret
	}
	return *o.KeyPassphrase.Get()
}

// GetKeyPassphraseOk returns a tuple with the KeyPassphrase field value if set, nil otherwise
// and a boolean to check if the value has been set.
// NOTE: If the value is an explicit nil, `nil, true` will be returned
func (o *GenerateCertificateRequest) GetKeyPassphraseOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return o.KeyPassphrase.Get(), o.KeyPassphrase.IsSet()
}

// HasKeyPassphrase returns a boolean if a field has been set.
func (o *GenerateCertificateRequest) HasKeyPassphrase() bool {
	if o != nil && o.KeyPassphrase.IsSet() {
		return true
	}

	return false
}

// SetKeyPassphrase gets a reference to the given NullableString and assigns it to the KeyPassphrase field.
func (o *GenerateCertificateRequest) SetKeyPassphrase(v string) {
	o.KeyPassphrase.Set(&v)
}
// SetKeyPassphraseNil sets the value for KeyPassphrase to be an explicit nil
func (o *GenerateCertificateRequest) SetKeyPassphraseNil() {
	o.KeyPassphrase.Set(nil)
}

// UnsetKeyPassphrase ensures that no value is present for KeyPassphrase, not even an explicit nil
func (o *GenerateCertificateRequest) UnsetKeyPassphrase() {
	o.KeyPassphrase.Unset()
}

// GetGenerateP12 returns the GenerateP12 field value if set, zero value otherwise.
func (o *GenerateCertificateRequest) GetGenerateP12() bool {
	if o == nil || IsNil(o.GenerateP12) {
		var ret bool
		return ret
	}
	return *o.GenerateP12
}

// GetGenerateP12Ok returns a tuple with the GenerateP12 field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GenerateCertificateRequest) GetGenerateP12Ok() (*bool, bool) {
	if o == nil || IsNil(o.GenerateP12) {
		return nil, false
	}
	return o.GenerateP12, true
}

// HasGenerateP12 returns a boolean if a field has been set.
func (o *GenerateCertificateRequest) HasGenerateP12() bool {
	if o != nil && !IsNil(o.GenerateP12) {
		return true
	}

	return false
}

// SetGenerateP12 gets a reference to the given bool and assigns it to the GenerateP12 field.
func (o *GenerateCertificateRequest) SetGenerateP12(v bool) {
	o.GenerateP12 = &v
}

// GetP12Passphrase returns the P12Passphrase field value if set, zero value otherwise.
func (o *GenerateCertificateRequest) GetP12Passphrase() string {
	if o == nil || IsNil(o.P12Passphrase) {
		var ret string
		return ret
	}
	return *o.P12Passphrase
}

// GetP12PassphraseOk returns a tuple with the P12Passphrase field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *GenerateCertificateRequest) GetP12PassphraseOk() (*string, bool) {
	if o == nil || IsNil(o.P12Passphrase) {
		return nil, false
	}
	return o.P12Passphrase, true
}

// HasP12Passphrase returns a boolean if a field has been set.
func (o *GenerateCertificateRequest) HasP12Passphrase() bool {
	if o != nil && !IsNil(o.P12Passphrase) {
		return true
	}

	return false
}

// SetP12Passphrase gets a reference to the given string and assigns it to the P12Passphrase field.
func (o *GenerateCertificateRequest) SetP12Passphrase(v string) {
	o.P12Passphrase = &v
}

func (o GenerateCertificateRequest) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o GenerateCertificateRequest) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.Cn) {
		toSerialize["cn"] = o.Cn
	}
	if !IsNil(o.Organization) {
		toSerialize["organization"] = o.Organization
	}
	if !IsNil(o.Country) {
		toSerialize["country"] = o.Country
	}
	if !IsNil(o.City) {
		toSerialize["city"] = o.City
	}
	if !IsNil(o.State) {
		toSerialize["state"] = o.State
	}
	if o.Email.IsSet() {
		toSerialize["email"] = o.Email.Get()
	}
	if !IsNil(o.ValidityDays) {
		toSerialize["validityDays"] = o.ValidityDays
	}
	if !IsNil(o.KeySize) {
		toSerialize["keySize"] = o.KeySize
	}
	if o.KeyPassphrase.IsSet() {
		toSerialize["keyPassphrase"] = o.KeyPassphrase.Get()
	}
	if !IsNil(o.GenerateP12) {
		toSerialize["generateP12"] = o.GenerateP12
	}
	if !IsNil(o.P12Passphrase) {
		toSerialize["p12Passphrase"] = o.P12Passphrase
	}
	return toSerialize, nil
}

type NullableGenerateCertificateRequest struct {
	value *GenerateCertificateRequest
	isSet bool
}

func (v NullableGenerateCertificateRequest) Get() *GenerateCertificateRequest {
	return v.value
}

func (v *NullableGenerateCertificateRequest) Set(val *GenerateCertificateRequest) {
	v.value = val
	v.isSet = true
}

func (v NullableGenerateCertificateRequest) IsSet() bool {
	return v.isSet
}

func (v *NullableGenerateCertificateRequest) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableGenerateCertificateRequest(val *GenerateCertificateRequest) *NullableGenerateCertificateRequest {
	return &NullableGenerateCertificateRequest{value: val, isSet: true}
}

func (v NullableGenerateCertificateRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableGenerateCertificateRequest) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


