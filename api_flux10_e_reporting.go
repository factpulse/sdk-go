/*
FactPulse REST API

 REST API for electronic invoicing in France: Factur-X, AFNOR PDP/PA, electronic signatures.  ## ðŸŽ¯ Main Features  ### ðŸ“„ Factur-X - Generation - **Formats**: XML only or PDF/A-3 with embedded XML - **Profiles**: MINIMUM, BASIC, EN16931, EXTENDED - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **ðŸ†• Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### âœ… Factur-X - Validation - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules)  ### âœï¸ Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification  ### ðŸ“‹ Flux 6 - Invoice Lifecycle (CDAR) - **CDAR Messages**: Acknowledgements, invoice statuses - **PPF Statuses**: REFUSED (210), PAID (212)  ### ðŸ“Š Flux 10 - E-Reporting - **Tax Declarations**: International B2B, B2C - **Flow Types**: 10.1 (B2B transactions), 10.2 (B2B payments), 10.3 (B2C transactions), 10.4 (B2C payments)  ### ðŸ“¡ AFNOR PDP/PA (XP Z12-013) - **Flow Service**: Submit and search flows to PDPs - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user  ### ðŸ›ï¸ Chorus Pro - **Public Sector Invoicing**: Complete API for Chorus Pro  ### â³ Async Tasks - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **Webhooks**: Automatic notifications when tasks complete  ## ðŸ”’ Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### ðŸ”‘ Method 1: `/api/token/` API (Recommended)  **URL:** `https://factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - âœ… Full automation (CI/CD, scripts) - âœ… Programmatic token management - âœ… Refresh token support for automatic access renewal - âœ… Easy integration in any language/tool  #### ðŸ–¥ï¸ Method 2: Dashboard Generation (Alternative)  **URL:** https://factpulse.fr/api/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - âœ… Quick for API testing - âœ… No password required - âœ… Simple visual interface  **Disadvantages:** - âŒ Requires manual action - âŒ No refresh token - âŒ Less suited for automation  ### ðŸ“š Full Documentation  For more information on authentication and API usage: https://factpulse.fr/documentation-api/     

API version: 1.0.0
Contact: contact@factpulse.fr
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package factpulse

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


// Flux10EReportingAPIService Flux10EReportingAPI service
type Flux10EReportingAPIService service

type ApiGenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPostRequest struct {
	ctx context.Context
	ApiService *Flux10EReportingAPIService
	createAggregatedReportRequest *CreateAggregatedReportRequest
}

func (r ApiGenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPostRequest) CreateAggregatedReportRequest(createAggregatedReportRequest CreateAggregatedReportRequest) ApiGenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPostRequest {
	r.createAggregatedReportRequest = &createAggregatedReportRequest
	return r
}

func (r ApiGenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPostRequest) Execute() (*GenerateAggregatedReportResponse, *http.Response, error) {
	return r.ApiService.GenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPostExecute(r)
}

/*
GenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPost Generate aggregated e-reporting XML (PPF-compliant)

Generate a PPF-compliant aggregated e-reporting XML containing multiple flux types in a single file.

This endpoint creates a Report XML that can contain:
- **TransactionsReport**: Invoice (10.1) AND/OR Transactions (10.3)
- **PaymentsReport**: Invoice payments (10.2) AND/OR Transaction payments (10.4)

The AFNOR FlowType is automatically determined based on content:
- Single type â†’ Specific FlowType (e.g., AggregatedCustomerTransactionReport)
- Multiple types â†’ MultiFlowReport

**CategoryCode (TT-81)** must use PPF-compliant values:
- TLB1: Goods deliveries
- TPS1: Service provisions
- TNT1: Non-taxed transactions
- TMA1: Mixed transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPostRequest
*/
func (a *Flux10EReportingAPIService) GenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPost(ctx context.Context) ApiGenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPostRequest {
	return ApiGenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GenerateAggregatedReportResponse
func (a *Flux10EReportingAPIService) GenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPostExecute(r ApiGenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPostRequest) (*GenerateAggregatedReportResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateAggregatedReportResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux10EReportingAPIService.GenerateAggregatedEreportingApiV1EreportingGenerateAggregatedPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ereporting/generate-aggregated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAggregatedReportRequest == nil {
		return localVarReturnValue, nil, reportError("createAggregatedReportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAggregatedReportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateEreportingApiV1EreportingGeneratePostRequest struct {
	ctx context.Context
	ApiService *Flux10EReportingAPIService
	createEReportingRequest *CreateEReportingRequest
}

func (r ApiGenerateEreportingApiV1EreportingGeneratePostRequest) CreateEReportingRequest(createEReportingRequest CreateEReportingRequest) ApiGenerateEreportingApiV1EreportingGeneratePostRequest {
	r.createEReportingRequest = &createEReportingRequest
	return r
}

func (r ApiGenerateEreportingApiV1EreportingGeneratePostRequest) Execute() (*GenerateEReportingResponse, *http.Response, error) {
	return r.ApiService.GenerateEreportingApiV1EreportingGeneratePostExecute(r)
}

/*
GenerateEreportingApiV1EreportingGeneratePost Generate e-reporting XML

Generate e-reporting XML (FRR format) from structured data.

Supports all four flow types:
- **10.1**: Unitary B2B international transactions (use `invoices` field)
- **10.2**: Payments for B2B international invoices (use `invoicePayments` field)
- **10.3**: Aggregated B2C transactions (use `transactions` field)
- **10.4**: Aggregated B2C payments (use `aggregatedPayments` field)

The generated XML is compliant with DGFIP specifications and ready
for submission to a PA (Plateforme AgrÃ©Ã©e).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateEreportingApiV1EreportingGeneratePostRequest
*/
func (a *Flux10EReportingAPIService) GenerateEreportingApiV1EreportingGeneratePost(ctx context.Context) ApiGenerateEreportingApiV1EreportingGeneratePostRequest {
	return ApiGenerateEreportingApiV1EreportingGeneratePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GenerateEReportingResponse
func (a *Flux10EReportingAPIService) GenerateEreportingApiV1EreportingGeneratePostExecute(r ApiGenerateEreportingApiV1EreportingGeneratePostRequest) (*GenerateEReportingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateEReportingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux10EReportingAPIService.GenerateEreportingApiV1EreportingGeneratePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ereporting/generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createEReportingRequest == nil {
		return localVarReturnValue, nil, reportError("createEReportingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createEReportingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateEreportingDownloadApiV1EreportingGenerateDownloadPostRequest struct {
	ctx context.Context
	ApiService *Flux10EReportingAPIService
	createEReportingRequest *CreateEReportingRequest
	filename *string
}

func (r ApiGenerateEreportingDownloadApiV1EreportingGenerateDownloadPostRequest) CreateEReportingRequest(createEReportingRequest CreateEReportingRequest) ApiGenerateEreportingDownloadApiV1EreportingGenerateDownloadPostRequest {
	r.createEReportingRequest = &createEReportingRequest
	return r
}

// Output filename (default: ereporting_{reportId}.xml)
func (r ApiGenerateEreportingDownloadApiV1EreportingGenerateDownloadPostRequest) Filename(filename string) ApiGenerateEreportingDownloadApiV1EreportingGenerateDownloadPostRequest {
	r.filename = &filename
	return r
}

func (r ApiGenerateEreportingDownloadApiV1EreportingGenerateDownloadPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.GenerateEreportingDownloadApiV1EreportingGenerateDownloadPostExecute(r)
}

/*
GenerateEreportingDownloadApiV1EreportingGenerateDownloadPost Generate and download e-reporting XML

Generate e-reporting XML and return as downloadable file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateEreportingDownloadApiV1EreportingGenerateDownloadPostRequest
*/
func (a *Flux10EReportingAPIService) GenerateEreportingDownloadApiV1EreportingGenerateDownloadPost(ctx context.Context) ApiGenerateEreportingDownloadApiV1EreportingGenerateDownloadPostRequest {
	return ApiGenerateEreportingDownloadApiV1EreportingGenerateDownloadPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *Flux10EReportingAPIService) GenerateEreportingDownloadApiV1EreportingGenerateDownloadPostExecute(r ApiGenerateEreportingDownloadApiV1EreportingGenerateDownloadPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux10EReportingAPIService.GenerateEreportingDownloadApiV1EreportingGenerateDownloadPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ereporting/generate/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createEReportingRequest == nil {
		return nil, reportError("createEReportingRequest is required and must be specified")
	}

	if r.filename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createEReportingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListCategoryCodesApiV1EreportingCategoryCodesGetRequest struct {
	ctx context.Context
	ApiService *Flux10EReportingAPIService
}

func (r ApiListCategoryCodesApiV1EreportingCategoryCodesGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListCategoryCodesApiV1EreportingCategoryCodesGetExecute(r)
}

/*
ListCategoryCodesApiV1EreportingCategoryCodesGet List PPF-compliant category codes

Returns the list of valid CategoryCode values (TT-81) for e-reporting transactions.

Source: Annexe 6 - Format sÃ©mantique FE e-reporting v1.9

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCategoryCodesApiV1EreportingCategoryCodesGetRequest
*/
func (a *Flux10EReportingAPIService) ListCategoryCodesApiV1EreportingCategoryCodesGet(ctx context.Context) ApiListCategoryCodesApiV1EreportingCategoryCodesGetRequest {
	return ApiListCategoryCodesApiV1EreportingCategoryCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *Flux10EReportingAPIService) ListCategoryCodesApiV1EreportingCategoryCodesGetExecute(r ApiListCategoryCodesApiV1EreportingCategoryCodesGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux10EReportingAPIService.ListCategoryCodesApiV1EreportingCategoryCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ereporting/category-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListFlowTypesApiV1EreportingFlowTypesGetRequest struct {
	ctx context.Context
	ApiService *Flux10EReportingAPIService
}

func (r ApiListFlowTypesApiV1EreportingFlowTypesGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListFlowTypesApiV1EreportingFlowTypesGetExecute(r)
}

/*
ListFlowTypesApiV1EreportingFlowTypesGet List available flow types

Returns the list of supported e-reporting flow types with descriptions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListFlowTypesApiV1EreportingFlowTypesGetRequest
*/
func (a *Flux10EReportingAPIService) ListFlowTypesApiV1EreportingFlowTypesGet(ctx context.Context) ApiListFlowTypesApiV1EreportingFlowTypesGetRequest {
	return ApiListFlowTypesApiV1EreportingFlowTypesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *Flux10EReportingAPIService) ListFlowTypesApiV1EreportingFlowTypesGetExecute(r ApiListFlowTypesApiV1EreportingFlowTypesGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux10EReportingAPIService.ListFlowTypesApiV1EreportingFlowTypesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ereporting/flow-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPostRequest struct {
	ctx context.Context
	ApiService *Flux10EReportingAPIService
	submitAggregatedReportRequest *SubmitAggregatedReportRequest
}

func (r ApiSubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPostRequest) SubmitAggregatedReportRequest(submitAggregatedReportRequest SubmitAggregatedReportRequest) ApiSubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPostRequest {
	r.submitAggregatedReportRequest = &submitAggregatedReportRequest
	return r
}

func (r ApiSubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPostRequest) Execute() (*SubmitEReportingResponse, *http.Response, error) {
	return r.ApiService.SubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPostExecute(r)
}

/*
SubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPost Submit aggregated e-reporting to PA/PDP

Generate and submit a PPF-compliant aggregated e-reporting to a PA/PDP.

Combines generation and submission in a single call.
Automatically determines the AFNOR FlowType based on content.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPostRequest
*/
func (a *Flux10EReportingAPIService) SubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPost(ctx context.Context) ApiSubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPostRequest {
	return ApiSubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitEReportingResponse
func (a *Flux10EReportingAPIService) SubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPostExecute(r ApiSubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPostRequest) (*SubmitEReportingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitEReportingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux10EReportingAPIService.SubmitAggregatedEreportingApiV1EreportingSubmitAggregatedPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ereporting/submit-aggregated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitAggregatedReportRequest == nil {
		return localVarReturnValue, nil, reportError("submitAggregatedReportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitAggregatedReportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitEreportingApiV1EreportingSubmitPostRequest struct {
	ctx context.Context
	ApiService *Flux10EReportingAPIService
	submitEReportingRequest *SubmitEReportingRequest
}

func (r ApiSubmitEreportingApiV1EreportingSubmitPostRequest) SubmitEReportingRequest(submitEReportingRequest SubmitEReportingRequest) ApiSubmitEreportingApiV1EreportingSubmitPostRequest {
	r.submitEReportingRequest = &submitEReportingRequest
	return r
}

func (r ApiSubmitEreportingApiV1EreportingSubmitPostRequest) Execute() (*SubmitEReportingResponse, *http.Response, error) {
	return r.ApiService.SubmitEreportingApiV1EreportingSubmitPostExecute(r)
}

/*
SubmitEreportingApiV1EreportingSubmitPost Submit e-reporting to PA/PDP

Generate and submit e-reporting to a PA (Plateforme AgrÃ©Ã©e).

Authentication strategies (same as invoices):
1. **JWT with client_uid** (recommended): PDP credentials fetched from backend
2. **Zero-storage**: Provide pdpFlowServiceUrl, pdpClientId, pdpClientSecret in request

The e-reporting is submitted using the AFNOR Flow Service API
with syntax=FRR (FRench Reporting).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitEreportingApiV1EreportingSubmitPostRequest
*/
func (a *Flux10EReportingAPIService) SubmitEreportingApiV1EreportingSubmitPost(ctx context.Context) ApiSubmitEreportingApiV1EreportingSubmitPostRequest {
	return ApiSubmitEreportingApiV1EreportingSubmitPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitEReportingResponse
func (a *Flux10EReportingAPIService) SubmitEreportingApiV1EreportingSubmitPostExecute(r ApiSubmitEreportingApiV1EreportingSubmitPostRequest) (*SubmitEReportingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitEReportingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux10EReportingAPIService.SubmitEreportingApiV1EreportingSubmitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ereporting/submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitEReportingRequest == nil {
		return localVarReturnValue, nil, reportError("submitEReportingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitEReportingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest struct {
	ctx context.Context
	ApiService *Flux10EReportingAPIService
	xmlFile *os.File
	trackingId *string
	skipValidation *bool
	pdpFlowServiceUrl *string
	pdpTokenUrl *string
	pdpClientId *string
	pdpClientSecret *string
}

// E-reporting XML file
func (r ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest) XmlFile(xmlFile *os.File) ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest {
	r.xmlFile = xmlFile
	return r
}

func (r ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest) TrackingId(trackingId string) ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest {
	r.trackingId = &trackingId
	return r
}

// Skip XSD validation
func (r ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest) SkipValidation(skipValidation bool) ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest {
	r.skipValidation = &skipValidation
	return r
}

func (r ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest) PdpFlowServiceUrl(pdpFlowServiceUrl string) ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest {
	r.pdpFlowServiceUrl = &pdpFlowServiceUrl
	return r
}

func (r ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest) PdpTokenUrl(pdpTokenUrl string) ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest {
	r.pdpTokenUrl = &pdpTokenUrl
	return r
}

func (r ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest) PdpClientId(pdpClientId string) ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest {
	r.pdpClientId = &pdpClientId
	return r
}

func (r ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest) PdpClientSecret(pdpClientSecret string) ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest {
	r.pdpClientSecret = &pdpClientSecret
	return r
}

func (r ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest) Execute() (*SubmitEReportingResponse, *http.Response, error) {
	return r.ApiService.SubmitXmlEreportingApiV1EreportingSubmitXmlPostExecute(r)
}

/*
SubmitXmlEreportingApiV1EreportingSubmitXmlPost Submit pre-generated e-reporting XML

Submit a pre-generated e-reporting XML file directly to a PA/PDP.

This endpoint is designed for clients who generate their own PPF-compliant XML
and only need FactPulse for the PDP submission.

**Process:**
1. Validates the XML against PPF XSD schemas
2. Determines the appropriate AFNOR FlowType
3. Submits to the configured PDP/PA
4. Returns the flowId for tracking

**Authentication:** Same strategies as /submit endpoint (JWT or zero-storage credentials).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest
*/
func (a *Flux10EReportingAPIService) SubmitXmlEreportingApiV1EreportingSubmitXmlPost(ctx context.Context) ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest {
	return ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitEReportingResponse
func (a *Flux10EReportingAPIService) SubmitXmlEreportingApiV1EreportingSubmitXmlPostExecute(r ApiSubmitXmlEreportingApiV1EreportingSubmitXmlPostRequest) (*SubmitEReportingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitEReportingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux10EReportingAPIService.SubmitXmlEreportingApiV1EreportingSubmitXmlPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ereporting/submit-xml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xmlFile == nil {
		return localVarReturnValue, nil, reportError("xmlFile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var xmlFileLocalVarFormFileName string
	var xmlFileLocalVarFileName     string
	var xmlFileLocalVarFileBytes    []byte

	xmlFileLocalVarFormFileName = "xml_file"
	xmlFileLocalVarFile := r.xmlFile

	if xmlFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(xmlFileLocalVarFile)

		xmlFileLocalVarFileBytes = fbs
		xmlFileLocalVarFileName = xmlFileLocalVarFile.Name()
		xmlFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: xmlFileLocalVarFileBytes, fileName: xmlFileLocalVarFileName, formFileName: xmlFileLocalVarFormFileName})
	}
	if r.trackingId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tracking_id", r.trackingId, "", "")
	}
	if r.skipValidation != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "skip_validation", r.skipValidation, "", "")
	}
	if r.pdpFlowServiceUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pdp_flow_service_url", r.pdpFlowServiceUrl, "", "")
	}
	if r.pdpTokenUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pdp_token_url", r.pdpTokenUrl, "", "")
	}
	if r.pdpClientId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pdp_client_id", r.pdpClientId, "", "")
	}
	if r.pdpClientSecret != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "pdp_client_secret", r.pdpClientSecret, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateAggregatedEreportingApiV1EreportingValidateAggregatedPostRequest struct {
	ctx context.Context
	ApiService *Flux10EReportingAPIService
	createAggregatedReportRequest *CreateAggregatedReportRequest
}

func (r ApiValidateAggregatedEreportingApiV1EreportingValidateAggregatedPostRequest) CreateAggregatedReportRequest(createAggregatedReportRequest CreateAggregatedReportRequest) ApiValidateAggregatedEreportingApiV1EreportingValidateAggregatedPostRequest {
	r.createAggregatedReportRequest = &createAggregatedReportRequest
	return r
}

func (r ApiValidateAggregatedEreportingApiV1EreportingValidateAggregatedPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidateAggregatedEreportingApiV1EreportingValidateAggregatedPostExecute(r)
}

/*
ValidateAggregatedEreportingApiV1EreportingValidateAggregatedPost Validate aggregated e-reporting data

Validates aggregated e-reporting data without generating XML.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateAggregatedEreportingApiV1EreportingValidateAggregatedPostRequest
*/
func (a *Flux10EReportingAPIService) ValidateAggregatedEreportingApiV1EreportingValidateAggregatedPost(ctx context.Context) ApiValidateAggregatedEreportingApiV1EreportingValidateAggregatedPostRequest {
	return ApiValidateAggregatedEreportingApiV1EreportingValidateAggregatedPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *Flux10EReportingAPIService) ValidateAggregatedEreportingApiV1EreportingValidateAggregatedPostExecute(r ApiValidateAggregatedEreportingApiV1EreportingValidateAggregatedPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux10EReportingAPIService.ValidateAggregatedEreportingApiV1EreportingValidateAggregatedPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ereporting/validate-aggregated"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAggregatedReportRequest == nil {
		return localVarReturnValue, nil, reportError("createAggregatedReportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAggregatedReportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateEreportingApiV1EreportingValidatePostRequest struct {
	ctx context.Context
	ApiService *Flux10EReportingAPIService
	validateEReportingRequest *ValidateEReportingRequest
}

func (r ApiValidateEreportingApiV1EreportingValidatePostRequest) ValidateEReportingRequest(validateEReportingRequest ValidateEReportingRequest) ApiValidateEreportingApiV1EreportingValidatePostRequest {
	r.validateEReportingRequest = &validateEReportingRequest
	return r
}

func (r ApiValidateEreportingApiV1EreportingValidatePostRequest) Execute() (*ValidateEReportingResponse, *http.Response, error) {
	return r.ApiService.ValidateEreportingApiV1EreportingValidatePostExecute(r)
}

/*
ValidateEreportingApiV1EreportingValidatePost Validate e-reporting data

Validate e-reporting data without generating or submitting.

Performs:
- Schema validation
- Business rule validation (correct flux type vs data)
- Data consistency checks (tax totals, dates, etc.)

Returns validation errors and warnings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateEreportingApiV1EreportingValidatePostRequest
*/
func (a *Flux10EReportingAPIService) ValidateEreportingApiV1EreportingValidatePost(ctx context.Context) ApiValidateEreportingApiV1EreportingValidatePostRequest {
	return ApiValidateEreportingApiV1EreportingValidatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ValidateEReportingResponse
func (a *Flux10EReportingAPIService) ValidateEreportingApiV1EreportingValidatePostExecute(r ApiValidateEreportingApiV1EreportingValidatePostRequest) (*ValidateEReportingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateEReportingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux10EReportingAPIService.ValidateEreportingApiV1EreportingValidatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ereporting/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.validateEReportingRequest == nil {
		return localVarReturnValue, nil, reportError("validateEReportingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validateEReportingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest struct {
	ctx context.Context
	ApiService *Flux10EReportingAPIService
	xmlFile *os.File
	validateCoherence *bool
	validatePeriod *bool
}

// E-reporting XML file to validate
func (r ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest) XmlFile(xmlFile *os.File) ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest {
	r.xmlFile = xmlFile
	return r
}

// Validate data coherence (REJ_COH)
func (r ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest) ValidateCoherence(validateCoherence bool) ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest {
	r.validateCoherence = &validateCoherence
	return r
}

// Validate period coherence (REJ_PER)
func (r ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest) ValidatePeriod(validatePeriod bool) ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest {
	r.validatePeriod = &validatePeriod
	return r
}

func (r ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidateXmlEreportingApiV1EreportingValidateXmlPostExecute(r)
}

/*
ValidateXmlEreportingApiV1EreportingValidateXmlPost Validate e-reporting XML (PPF Annexe 6 v1.9 compliant)

Validates an e-reporting XML file against PPF specifications (Annexe 6 v1.9):

**Validation levels:**
1. **XSD (REJ_SEMAN)**: Structure, types, cardinality
2. **Semantic (REJ_SEMAN)**: Authorized values from codelists
3. **Coherence (REJ_COH)**: Data consistency (totals = sum of breakdowns)
4. **Period (REJ_PER)**: Transaction dates within declared period

**Validated codes:**
- SchemeID (ISO 6523): 0002=SIREN, 0009=SIRET, 0224=RoutingCode, etc.
- RoleCode (UNCL 3035): SE=Seller, BY=Buyer, WK=Working party
- CategoryCode (TT-81): TLB1, TPS1, TNT1, TMA1
- TaxCategoryCode (UNTDID 5305): S, Z, E, AE, K, G, O
- Currency (ISO 4217), Country (ISO 3166-1)

Returns structured validation errors with PPF rejection codes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest
*/
func (a *Flux10EReportingAPIService) ValidateXmlEreportingApiV1EreportingValidateXmlPost(ctx context.Context) ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest {
	return ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *Flux10EReportingAPIService) ValidateXmlEreportingApiV1EreportingValidateXmlPostExecute(r ApiValidateXmlEreportingApiV1EreportingValidateXmlPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux10EReportingAPIService.ValidateXmlEreportingApiV1EreportingValidateXmlPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/ereporting/validate-xml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xmlFile == nil {
		return localVarReturnValue, nil, reportError("xmlFile is required and must be specified")
	}

	if r.validateCoherence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validate_coherence", r.validateCoherence, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "validate_coherence", defaultValue, "form", "")
		r.validateCoherence = &defaultValue
	}
	if r.validatePeriod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validate_period", r.validatePeriod, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "validate_period", defaultValue, "form", "")
		r.validatePeriod = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var xmlFileLocalVarFormFileName string
	var xmlFileLocalVarFileName     string
	var xmlFileLocalVarFileBytes    []byte

	xmlFileLocalVarFormFileName = "xml_file"
	xmlFileLocalVarFile := r.xmlFile

	if xmlFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(xmlFileLocalVarFile)

		xmlFileLocalVarFileBytes = fbs
		xmlFileLocalVarFileName = xmlFileLocalVarFile.Name()
		xmlFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: xmlFileLocalVarFileBytes, fileName: xmlFileLocalVarFileName, formFileName: xmlFileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
