/*
FactPulse REST API

 REST API for electronic invoicing in France: Factur-X, AFNOR PDP/PA, electronic signatures.  ## ðŸŽ¯ Main Features  ### ðŸ“„ Factur-X - Generation - **Formats**: XML only or PDF/A-3 with embedded XML - **Profiles**: MINIMUM, BASIC, EN16931, EXTENDED - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **ðŸ†• Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### âœ… Factur-X - Validation - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules)  ### âœï¸ Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification  ### ðŸ“‹ Flux 6 - Invoice Lifecycle (CDAR) - **CDAR Messages**: Acknowledgements, invoice statuses - **PPF Statuses**: REFUSED (210), PAID (212)  ### ðŸ“Š Flux 10 - E-Reporting - **Tax Declarations**: International B2B, B2C - **Flow Types**: 10.1 (B2B transactions), 10.2 (B2B payments), 10.3 (B2C transactions), 10.4 (B2C payments)  ### ðŸ“¡ AFNOR PDP/PA (XP Z12-013) - **Flow Service**: Submit and search flows to PDPs - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user  ### ðŸ›ï¸ Chorus Pro - **Public Sector Invoicing**: Complete API for Chorus Pro  ### â³ Async Tasks - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **Webhooks**: Automatic notifications when tasks complete  ## ðŸ”’ Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### ðŸ”‘ Method 1: `/api/token/` API (Recommended)  **URL:** `https://factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - âœ… Full automation (CI/CD, scripts) - âœ… Programmatic token management - âœ… Refresh token support for automatic access renewal - âœ… Easy integration in any language/tool  #### ðŸ–¥ï¸ Method 2: Dashboard Generation (Alternative)  **URL:** https://factpulse.fr/api/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - âœ… Quick for API testing - âœ… No password required - âœ… Simple visual interface  **Disadvantages:** - âŒ Requires manual action - âŒ No refresh token - âŒ Less suited for automation  ### ðŸ“š Full Documentation  For more information on authentication and API usage: https://factpulse.fr/documentation-api/     

API version: 1.0.0
Contact: contact@factpulse.fr
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package factpulse

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


// FacturXGenerationAPIService FacturXGenerationAPI service
type FacturXGenerationAPIService service

type ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest struct {
	ctx context.Context
	ApiService *FacturXGenerationAPIService
	invoiceData *string
	profile *APIProfile
	outputFormat *OutputFormat
	autoEnrich *bool
	sourcePdf *os.File
	callbackUrl *string
	webhookMode *string
	skipBrFr *bool
}

// Invoice data in JSON format.              Two formats accepted:             1. **Classic format**: Complete FacturXInvoice structure (all fields)             2. **Simplified format** (ðŸ†• P0.1): Minimal structure with auto-enrichment              Format is detected automatically!             
func (r ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest) InvoiceData(invoiceData string) ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest {
	r.invoiceData = &invoiceData
	return r
}

// Factur-X profile: MINIMUM, BASIC, EN16931 or EXTENDED.
func (r ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest) Profile(profile APIProfile) ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest {
	r.profile = &profile
	return r
}

// Output format: &#39;xml&#39; (XML only) or &#39;pdf&#39; (Factur-X PDF with embedded XML).
func (r ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest) OutputFormat(outputFormat OutputFormat) ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest {
	r.outputFormat = &outputFormat
	return r
}

// ðŸ†• Enable auto-enrichment from SIRET/SIREN (simplified format only)
func (r ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest) AutoEnrich(autoEnrich bool) ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest {
	r.autoEnrich = &autoEnrich
	return r
}

func (r ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest) SourcePdf(sourcePdf *os.File) ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest {
	r.sourcePdf = sourcePdf
	return r
}

func (r ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest) CallbackUrl(callbackUrl string) ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest {
	r.callbackUrl = &callbackUrl
	return r
}

// Webhook content delivery: &#39;inline&#39; (base64 in payload) or &#39;download_url&#39; (temporary URL, 1h TTL)
func (r ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest) WebhookMode(webhookMode string) ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest {
	r.webhookMode = &webhookMode
	return r
}

func (r ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest) SkipBrFr(skipBrFr bool) ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest {
	r.skipBrFr = &skipBrFr
	return r
}

func (r ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest) Execute() (*TaskResponse, *http.Response, error) {
	return r.ApiService.GenerateInvoiceApiV1ProcessingGenerateInvoicePostExecute(r)
}

/*
GenerateInvoiceApiV1ProcessingGenerateInvoicePost Generate a Factur-X invoice

Generates an electronic invoice in Factur-X format compliant with European standards.

## Applied Standards

- **Factur-X** (France): FNFE-MPE standard (Forum National de la Facture Ã‰lectronique)
- **ZUGFeRD** (Germany): German format compatible with Factur-X
- **EN 16931**: European semantic standard for electronic invoicing
- **ISO 19005-3** (PDF/A-3): Long-term electronic archiving
- **Cross Industry Invoice (CII)**: UN/CEFACT XML syntax

## ðŸ†• New: Simplified format with auto-enrichment (P0.1)

You can now create an invoice by providing only:
- An invoice number
- A supplier SIRET + **IBAN** (required)
- A recipient SIRET
- Invoice lines (description, quantity, net price)

**Simplified format example**:
```json
{
  "number": "FACT-2025-001",
  "supplier": {
    "siret": "92019522900017",
    "iban": "FR7630001007941234567890185"
  },
  "recipient": {"siret": "35600000000048"},
  "lines": [
    {"description": "Service", "quantity": 10, "unitPrice": 100.00, "vatRate": 20.0}
  ]
}
```

**âš ï¸ Required fields (simplified format)**:
- `number`: Unique invoice number
- `supplier.siret`: Supplier's SIRET (14 digits)
- `supplier.iban`: Bank account IBAN (no public API to retrieve it)
- `recipient.siret`: Recipient's SIRET
- `lines[]`: At least one invoice line

**What happens automatically with `auto_enrich=True`**:
- âœ… Name enrichment from Chorus Pro API
- âœ… Address enrichment from Business Search API (free, public)
- âœ… Automatic intra-EU VAT calculation (FR + key + SIREN)
- âœ… Chorus Pro ID retrieval for electronic invoicing
- âœ… Net/VAT/Gross totals calculation
- âœ… Date generation (today + 30-day due date)
- âœ… Multi-rate VAT handling

**Supported identifiers**:
- SIRET (14 digits): Specific establishment â­ Recommended
- SIREN (9 digits): Company (auto-selection of headquarters)
- Special types: UE_HORS_FRANCE, RIDET, TAHITI, etc.

## Checks performed during generation

### 1. Data validation (Pydantic)
- Data types (amounts as Decimal, ISO 8601 dates)
- Formats (14-digit SIRET, 9-digit SIREN, IBAN)
- Required fields per profile
- Amount consistency (Net + VAT = Gross)

### 2. CII-compliant XML generation
- Serialization according to Cross Industry Invoice XSD schema
- Correct UN/CEFACT namespaces
- Hierarchical structure respected
- UTF-8 encoding without BOM

### 3. Schematron validation
- Business rules for selected profile (MINIMUM, BASIC, EN16931, EXTENDED)
- Element cardinality (required, optional, repeatable)
- Calculation rules (totals, VAT, discounts)
- European EN 16931 compliance

### 4. PDF/A-3 conversion (if output_format='pdf')
- Source PDF conversion to PDF/A-3 via Ghostscript
- Factur-X XML embedding in PDF
- Compliant XMP metadata
- ICC sRGB color profile
- Removal of forbidden elements (JavaScript, forms)

## How it works

1. **Submission**: Invoice is queued in Celery for asynchronous processing
2. **Immediate return**: You receive a `task_id` (HTTP 202 Accepted)
3. **Tracking**: Use the `/tasks/{task_id}/status` endpoint to track progress

## Webhook notification (recommended)

Instead of polling, you can receive a webhook notification when the task completes:

```
callback_url=https://your-server.com/webhook
```

The webhook will POST a JSON payload with:
- `event_type`: `generation.completed` or `generation.failed`
- `data.task_id`: The Celery task ID
- `data.content_b64` or `data.xml_content`: The generated content
- `X-Webhook-Signature` header for HMAC verification

See `/docs/WEBHOOKS.md` for full documentation.

## Output formats

- **xml**: Generates only Factur-X XML (recommended for testing)
- **pdf**: Generates PDF/A-3 with embedded XML (requires `source_pdf`)

## Factur-X profiles

- **MINIMUM**: Minimal data (simplified invoice)
- **BASIC**: Basic information (SMEs)
- **EN16931**: European standard (recommended, compliant with directive 2014/55/EU)
- **EXTENDED**: All available data (large accounts)

## What you get

After successful processing (status `completed`):
- **XML only**: Base64-encoded Factur-X compliant XML file
- **PDF/A-3**: PDF with embedded XML, ready for sending/archiving
- **Metadata**: Profile, Factur-X version, file size
- **Validation**: Schematron compliance confirmation

## Validation

Data is automatically validated according to detected format.
On error, a 422 status is returned with invalid field details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest
*/
func (a *FacturXGenerationAPIService) GenerateInvoiceApiV1ProcessingGenerateInvoicePost(ctx context.Context) ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest {
	return ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaskResponse
func (a *FacturXGenerationAPIService) GenerateInvoiceApiV1ProcessingGenerateInvoicePostExecute(r ApiGenerateInvoiceApiV1ProcessingGenerateInvoicePostRequest) (*TaskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FacturXGenerationAPIService.GenerateInvoiceApiV1ProcessingGenerateInvoicePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/processing/generate-invoice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.invoiceData == nil {
		return localVarReturnValue, nil, reportError("invoiceData is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "invoice_data", r.invoiceData, "", "")
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "profile", r.profile, "", "")
	}
	if r.outputFormat != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "output_format", r.outputFormat, "", "")
	}
	if r.autoEnrich != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "auto_enrich", r.autoEnrich, "", "")
	}
	var sourcePdfLocalVarFormFileName string
	var sourcePdfLocalVarFileName     string
	var sourcePdfLocalVarFileBytes    []byte

	sourcePdfLocalVarFormFileName = "source_pdf"
	sourcePdfLocalVarFile := r.sourcePdf

	if sourcePdfLocalVarFile != nil {
		fbs, _ := io.ReadAll(sourcePdfLocalVarFile)

		sourcePdfLocalVarFileBytes = fbs
		sourcePdfLocalVarFileName = sourcePdfLocalVarFile.Name()
		sourcePdfLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: sourcePdfLocalVarFileBytes, fileName: sourcePdfLocalVarFileName, formFileName: sourcePdfLocalVarFormFileName})
	}
	if r.callbackUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "callback_url", r.callbackUrl, "", "")
	}
	if r.webhookMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "webhook_mode", r.webhookMode, "", "")
	}
	if r.skipBrFr != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "skip_br_fr", r.skipBrFr, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePostRequest struct {
	ctx context.Context
	ApiService *FacturXGenerationAPIService
	submitCompleteInvoiceRequest *SubmitCompleteInvoiceRequest
}

func (r ApiSubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePostRequest) SubmitCompleteInvoiceRequest(submitCompleteInvoiceRequest SubmitCompleteInvoiceRequest) ApiSubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePostRequest {
	r.submitCompleteInvoiceRequest = &submitCompleteInvoiceRequest
	return r
}

func (r ApiSubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePostRequest) Execute() (*SubmitCompleteInvoiceResponse, *http.Response, error) {
	return r.ApiService.SubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePostExecute(r)
}

/*
SubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePost Submit a complete invoice (generation + signature + submission)

Unified endpoint to submit a complete invoice to different destinations.
    **Facture prÃªte pour Flux 2** - GÃ©nÃ¨re une facture Factur-X complÃ¨te avec signature optionnelle et soumission vers Chorus Pro ou PDP AFNOR.

    **Automated workflow:**
    1. **Auto-enrichment** (optional): retrieves data via public APIs and Chorus Pro/AFNOR
    2. **Factur-X PDF generation**: creates a PDF/A-3 with embedded XML
    3. **Electronic signature** (optional): signs the PDF with a certificate
    4. **Submission**: sends to the chosen destination (Chorus Pro or AFNOR PDP)

    **Supported destinations:**
    - **Chorus Pro**: French B2G platform (invoices to public sector)
    - **AFNOR PDP**: Partner Dematerialization Platforms

    **Destination credentials - 2 modes available:**

    **Mode 1 - Retrieval via JWT (recommended):**
    - Credentials are retrieved automatically via the JWT `client_uid`
    - Do not provide the `credentials` field in `destination`
    - Zero-trust architecture: no secrets in the payload
    - Example: `"destination": {"type": "chorus_pro"}`

    **Mode 2 - Credentials in the payload:**
    - Provide credentials directly in the payload
    - Useful for tests or third-party integrations
    - Example: `"destination": {"type": "chorus_pro", "credentials": {...}}`


    **Electronic signature (optional) - 2 modes available:**

    **Mode 1 - Stored certificate (recommended):**
    - Certificate is retrieved automatically via the JWT `client_uid`
    - No key to provide in the payload
    - PAdES-B-LT signature with timestamp (eIDAS compliant)
    - Example: `"signature": {"reason": "Factur-X compliance"}`

    **Mode 2 - Keys in the payload (for tests):**
    - Provide `key_pem` and `cert_pem` directly
    - PEM format accepted: raw or base64
    - Useful for tests or special cases without stored certificate
    - Example: `"signature": {"key_pem": "-----BEGIN...", "cert_pem": "-----BEGIN..."}`

    If `key_pem` and `cert_pem` are provided â†’ Mode 2
    Otherwise â†’ Mode 1 (certificate retrieved via `client_uid`)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePostRequest
*/
func (a *FacturXGenerationAPIService) SubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePost(ctx context.Context) ApiSubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePostRequest {
	return ApiSubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitCompleteInvoiceResponse
func (a *FacturXGenerationAPIService) SubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePostExecute(r ApiSubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePostRequest) (*SubmitCompleteInvoiceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitCompleteInvoiceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FacturXGenerationAPIService.SubmitCompleteInvoiceApiV1ProcessingInvoicesSubmitCompletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/processing/invoices/submit-complete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitCompleteInvoiceRequest == nil {
		return localVarReturnValue, nil, reportError("submitCompleteInvoiceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitCompleteInvoiceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest struct {
	ctx context.Context
	ApiService *FacturXGenerationAPIService
	submitCompleteInvoiceRequest *SubmitCompleteInvoiceRequest
	callbackUrl *string
	webhookMode *string
}

func (r ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest) SubmitCompleteInvoiceRequest(submitCompleteInvoiceRequest SubmitCompleteInvoiceRequest) ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest {
	r.submitCompleteInvoiceRequest = &submitCompleteInvoiceRequest
	return r
}

// Webhook URL for async notification when submission completes.
func (r ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest) CallbackUrl(callbackUrl string) ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest {
	r.callbackUrl = &callbackUrl
	return r
}

// Webhook content delivery: &#39;inline&#39; (base64 in payload) or &#39;download_url&#39; (temporary URL, 1h TTL)
func (r ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest) WebhookMode(webhookMode string) ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest {
	r.webhookMode = &webhookMode
	return r
}

func (r ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest) Execute() (*TaskResponse, *http.Response, error) {
	return r.ApiService.SubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostExecute(r)
}

/*
SubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPost Submit a complete invoice (asynchronous with Celery)

Asynchronous version of the `/invoices/submit-complete` endpoint using Celery for background processing.
    **Facture prÃªte pour Flux 2** - GÃ©nÃ¨re une facture Factur-X complÃ¨te de maniÃ¨re asynchrone.

    **Automated workflow (same as synchronous version):**
    1. **Auto-enrichment** (optional): retrieves data via public APIs and Chorus Pro/AFNOR
    2. **Factur-X PDF generation**: creates a PDF/A-3 with embedded XML
    3. **Electronic signature** (optional): signs the PDF with a certificate
    4. **Submission**: sends to the chosen destination (Chorus Pro or AFNOR PDP)

    **Supported destinations:**
    - **Chorus Pro**: French B2G platform (invoices to public sector)
    - **AFNOR PDP**: Partner Dematerialization Platforms

    **Differences with synchronous version:**
    - âœ… **Non-blocking**: Returns immediately with a `task_id` (HTTP 202 Accepted)
    - âœ… **Background processing**: Invoice is processed by a Celery worker
    - âœ… **Progress tracking**: Use `/tasks/{task_id}/status` to track status
    - âœ… **Ideal for high volumes**: Allows processing many invoices in parallel

    **How to use:**
    1. **Submission**: Call this endpoint with your invoice data
    2. **Immediate return**: You receive a `task_id` (e.g., "abc123-def456")
    3. **Tracking**: Call `/tasks/{task_id}/status` to check progress
    4. **Result**: When `status = "SUCCESS"`, the `result` field contains the complete response

    **Webhook notification (recommended):**

    Instead of polling, add `?callback_url=https://your-server.com/webhook` to receive automatic notification:
    - `event_type`: `submission.completed`, `submission.failed`, or `submission.partial`
    - `data.submission_result`: Complete submission result
    - `X-Webhook-Signature` header for HMAC verification

    **Credentials and signature**: Same modes as the synchronous version (JWT or payload).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest
*/
func (a *FacturXGenerationAPIService) SubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPost(ctx context.Context) ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest {
	return ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaskResponse
func (a *FacturXGenerationAPIService) SubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostExecute(r ApiSubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPostRequest) (*TaskResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FacturXGenerationAPIService.SubmitCompleteInvoiceAsyncApiV1ProcessingInvoicesSubmitCompleteAsyncPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/processing/invoices/submit-complete-async"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitCompleteInvoiceRequest == nil {
		return localVarReturnValue, nil, reportError("submitCompleteInvoiceRequest is required and must be specified")
	}

	if r.callbackUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "callback_url", r.callbackUrl, "form", "")
	}
	if r.webhookMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webhook_mode", r.webhookMode, "form", "")
	} else {
		var defaultValue string = "inline"
		parameterAddToHeaderOrQuery(localVarQueryParams, "webhook_mode", defaultValue, "form", "")
		r.webhookMode = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitCompleteInvoiceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
