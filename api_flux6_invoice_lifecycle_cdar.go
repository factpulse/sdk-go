/*
FactPulse REST API

 REST API for electronic invoicing in France: Factur-X, AFNOR PDP/PA, electronic signatures.  ## ðŸŽ¯ Main Features  ### ðŸ“„ Factur-X - Generation - **Formats**: XML only or PDF/A-3 with embedded XML - **Profiles**: MINIMUM, BASIC, EN16931, EXTENDED - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **ðŸ†• Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### âœ… Factur-X - Validation - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules)  ### âœï¸ Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification  ### ðŸ“‹ Flux 6 - Invoice Lifecycle (CDAR) - **CDAR Messages**: Acknowledgements, invoice statuses - **PPF Statuses**: REFUSED (210), PAID (212)  ### ðŸ“Š Flux 10 - E-Reporting - **Tax Declarations**: International B2B, B2C - **Flow Types**: 10.1 (B2B transactions), 10.2 (B2B payments), 10.3 (B2C transactions), 10.4 (B2C payments)  ### ðŸ“¡ AFNOR PDP/PA (XP Z12-013) - **Flow Service**: Submit and search flows to PDPs - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user  ### ðŸ›ï¸ Chorus Pro - **Public Sector Invoicing**: Complete API for Chorus Pro  ### â³ Async Tasks - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **Webhooks**: Automatic notifications when tasks complete  ## ðŸ”’ Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### ðŸ”‘ Method 1: `/api/token/` API (Recommended)  **URL:** `https://factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - âœ… Full automation (CI/CD, scripts) - âœ… Programmatic token management - âœ… Refresh token support for automatic access renewal - âœ… Easy integration in any language/tool  #### ðŸ–¥ï¸ Method 2: Dashboard Generation (Alternative)  **URL:** https://factpulse.fr/api/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - âœ… Quick for API testing - âœ… No password required - âœ… Simple visual interface  **Disadvantages:** - âŒ Requires manual action - âŒ No refresh token - âŒ Less suited for automation  ### ðŸ“š Full Documentation  For more information on authentication and API usage: https://factpulse.fr/documentation-api/     

API version: 1.0.0
Contact: contact@factpulse.fr
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package factpulse

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


// Flux6InvoiceLifecycleCDARAPIService Flux6InvoiceLifecycleCDARAPI service
type Flux6InvoiceLifecycleCDARAPIService service

type ApiGenerateCdarApiV1CdarGeneratePostRequest struct {
	ctx context.Context
	ApiService *Flux6InvoiceLifecycleCDARAPIService
	createCDARRequest *CreateCDARRequest
}

func (r ApiGenerateCdarApiV1CdarGeneratePostRequest) CreateCDARRequest(createCDARRequest CreateCDARRequest) ApiGenerateCdarApiV1CdarGeneratePostRequest {
	r.createCDARRequest = &createCDARRequest
	return r
}

func (r ApiGenerateCdarApiV1CdarGeneratePostRequest) Execute() (*GenerateCDARResponse, *http.Response, error) {
	return r.ApiService.GenerateCdarApiV1CdarGeneratePostExecute(r)
}

/*
GenerateCdarApiV1CdarGeneratePost Generate a CDAR message

Generate a CDAR XML message (Cross Domain Acknowledgement and Response)
to communicate the status of an invoice.

**Message types:**
- **23** (Processing): Standard lifecycle message
- **305** (Transmission): Inter-platform transmission message

**Business rules:**
- BR-FR-CDV-14: Status 212 (PAID) requires a paid amount
- BR-FR-CDV-15: Statuses 206/207/208/210/213/501 require a reason code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateCdarApiV1CdarGeneratePostRequest
*/
func (a *Flux6InvoiceLifecycleCDARAPIService) GenerateCdarApiV1CdarGeneratePost(ctx context.Context) ApiGenerateCdarApiV1CdarGeneratePostRequest {
	return ApiGenerateCdarApiV1CdarGeneratePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GenerateCDARResponse
func (a *Flux6InvoiceLifecycleCDARAPIService) GenerateCdarApiV1CdarGeneratePostExecute(r ApiGenerateCdarApiV1CdarGeneratePostRequest) (*GenerateCDARResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateCDARResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux6InvoiceLifecycleCDARAPIService.GenerateCdarApiV1CdarGeneratePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCDARRequest == nil {
		return localVarReturnValue, nil, reportError("createCDARRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCDARRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActionCodesApiV1CdarActionCodesGetRequest struct {
	ctx context.Context
	ApiService *Flux6InvoiceLifecycleCDARAPIService
}

func (r ApiGetActionCodesApiV1CdarActionCodesGetRequest) Execute() (*ActionCodesResponse, *http.Response, error) {
	return r.ApiService.GetActionCodesApiV1CdarActionCodesGetExecute(r)
}

/*
GetActionCodesApiV1CdarActionCodesGet List of CDAR action codes

Returns the complete list of action codes (BR-FR-CDV-CL-10).

These codes indicate the requested action on the invoice.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActionCodesApiV1CdarActionCodesGetRequest
*/
func (a *Flux6InvoiceLifecycleCDARAPIService) GetActionCodesApiV1CdarActionCodesGet(ctx context.Context) ApiGetActionCodesApiV1CdarActionCodesGetRequest {
	return ApiGetActionCodesApiV1CdarActionCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionCodesResponse
func (a *Flux6InvoiceLifecycleCDARAPIService) GetActionCodesApiV1CdarActionCodesGetExecute(r ApiGetActionCodesApiV1CdarActionCodesGetRequest) (*ActionCodesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionCodesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux6InvoiceLifecycleCDARAPIService.GetActionCodesApiV1CdarActionCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/action-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReasonCodesApiV1CdarReasonCodesGetRequest struct {
	ctx context.Context
	ApiService *Flux6InvoiceLifecycleCDARAPIService
}

func (r ApiGetReasonCodesApiV1CdarReasonCodesGetRequest) Execute() (*ReasonCodesResponse, *http.Response, error) {
	return r.ApiService.GetReasonCodesApiV1CdarReasonCodesGetExecute(r)
}

/*
GetReasonCodesApiV1CdarReasonCodesGet List of CDAR reason codes

Returns the complete list of status reason codes (BR-FR-CDV-CL-09).

These codes explain the reason for a particular status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReasonCodesApiV1CdarReasonCodesGetRequest
*/
func (a *Flux6InvoiceLifecycleCDARAPIService) GetReasonCodesApiV1CdarReasonCodesGet(ctx context.Context) ApiGetReasonCodesApiV1CdarReasonCodesGetRequest {
	return ApiGetReasonCodesApiV1CdarReasonCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReasonCodesResponse
func (a *Flux6InvoiceLifecycleCDARAPIService) GetReasonCodesApiV1CdarReasonCodesGetExecute(r ApiGetReasonCodesApiV1CdarReasonCodesGetRequest) (*ReasonCodesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReasonCodesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux6InvoiceLifecycleCDARAPIService.GetReasonCodesApiV1CdarReasonCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/reason-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatusCodesApiV1CdarStatusCodesGetRequest struct {
	ctx context.Context
	ApiService *Flux6InvoiceLifecycleCDARAPIService
}

func (r ApiGetStatusCodesApiV1CdarStatusCodesGetRequest) Execute() (*StatusCodesResponse, *http.Response, error) {
	return r.ApiService.GetStatusCodesApiV1CdarStatusCodesGetExecute(r)
}

/*
GetStatusCodesApiV1CdarStatusCodesGet List of CDAR status codes

Returns the complete list of invoice status codes (BR-FR-CDV-CL-06).

These codes indicate the lifecycle state of an invoice.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetStatusCodesApiV1CdarStatusCodesGetRequest
*/
func (a *Flux6InvoiceLifecycleCDARAPIService) GetStatusCodesApiV1CdarStatusCodesGet(ctx context.Context) ApiGetStatusCodesApiV1CdarStatusCodesGetRequest {
	return ApiGetStatusCodesApiV1CdarStatusCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StatusCodesResponse
func (a *Flux6InvoiceLifecycleCDARAPIService) GetStatusCodesApiV1CdarStatusCodesGetExecute(r ApiGetStatusCodesApiV1CdarStatusCodesGetRequest) (*StatusCodesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatusCodesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux6InvoiceLifecycleCDARAPIService.GetStatusCodesApiV1CdarStatusCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/status-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitCdarApiV1CdarSubmitPostRequest struct {
	ctx context.Context
	ApiService *Flux6InvoiceLifecycleCDARAPIService
	submitCDARRequest *SubmitCDARRequest
}

func (r ApiSubmitCdarApiV1CdarSubmitPostRequest) SubmitCDARRequest(submitCDARRequest SubmitCDARRequest) ApiSubmitCdarApiV1CdarSubmitPostRequest {
	r.submitCDARRequest = &submitCDARRequest
	return r
}

func (r ApiSubmitCdarApiV1CdarSubmitPostRequest) Execute() (*SubmitCDARResponse, *http.Response, error) {
	return r.ApiService.SubmitCdarApiV1CdarSubmitPostExecute(r)
}

/*
SubmitCdarApiV1CdarSubmitPost Generate and submit a CDAR message

Generate a CDAR message and submit it to the PA/PDP platform.

**Authentication strategies:**
1. **JWT with client_uid** (recommended): PDP credentials retrieved from backend
2. **Zero-storage**: Provide pdpFlowServiceUrl, pdpClientId, pdpClientSecret in the request

**Flow types (flowType):**
- `CustomerInvoiceLC`: Client-side lifecycle (buyer)
- `SupplierInvoiceLC`: Supplier-side lifecycle (seller)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitCdarApiV1CdarSubmitPostRequest
*/
func (a *Flux6InvoiceLifecycleCDARAPIService) SubmitCdarApiV1CdarSubmitPost(ctx context.Context) ApiSubmitCdarApiV1CdarSubmitPostRequest {
	return ApiSubmitCdarApiV1CdarSubmitPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitCDARResponse
func (a *Flux6InvoiceLifecycleCDARAPIService) SubmitCdarApiV1CdarSubmitPostExecute(r ApiSubmitCdarApiV1CdarSubmitPostRequest) (*SubmitCDARResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitCDARResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux6InvoiceLifecycleCDARAPIService.SubmitCdarApiV1CdarSubmitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitCDARRequest == nil {
		return localVarReturnValue, nil, reportError("submitCDARRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitCDARRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest struct {
	ctx context.Context
	ApiService *Flux6InvoiceLifecycleCDARAPIService
	submitCDARXMLRequest *SubmitCDARXMLRequest
}

func (r ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest) SubmitCDARXMLRequest(submitCDARXMLRequest SubmitCDARXMLRequest) ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest {
	r.submitCDARXMLRequest = &submitCDARXMLRequest
	return r
}

func (r ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest) Execute() (*SubmitCDARResponse, *http.Response, error) {
	return r.ApiService.SubmitCdarXmlApiV1CdarSubmitXmlPostExecute(r)
}

/*
SubmitCdarXmlApiV1CdarSubmitXmlPost Submit a pre-generated CDAR XML

Submit a pre-generated CDAR XML message to the PA/PDP platform.

Useful for submitting XML generated by other systems.

**Validation:**
The XML is validated against XSD and Schematron BR-FR-CDV rules BEFORE submission.
Invalid XML will be rejected with detailed error messages.

**Authentication strategies:**
1. **JWT with client_uid** (recommended): PDP credentials retrieved from backend
2. **Zero-storage**: Provide pdpFlowServiceUrl, pdpClientId, pdpClientSecret in the request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest
*/
func (a *Flux6InvoiceLifecycleCDARAPIService) SubmitCdarXmlApiV1CdarSubmitXmlPost(ctx context.Context) ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest {
	return ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitCDARResponse
func (a *Flux6InvoiceLifecycleCDARAPIService) SubmitCdarXmlApiV1CdarSubmitXmlPostExecute(r ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest) (*SubmitCDARResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitCDARResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux6InvoiceLifecycleCDARAPIService.SubmitCdarXmlApiV1CdarSubmitXmlPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/submit-xml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitCDARXMLRequest == nil {
		return localVarReturnValue, nil, reportError("submitCDARXMLRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitCDARXMLRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitEncaisseeApiV1CdarEncaisseePostRequest struct {
	ctx context.Context
	ApiService *Flux6InvoiceLifecycleCDARAPIService
	encaisseeRequest *EncaisseeRequest
}

func (r ApiSubmitEncaisseeApiV1CdarEncaisseePostRequest) EncaisseeRequest(encaisseeRequest EncaisseeRequest) ApiSubmitEncaisseeApiV1CdarEncaisseePostRequest {
	r.encaisseeRequest = &encaisseeRequest
	return r
}

func (r ApiSubmitEncaisseeApiV1CdarEncaisseePostRequest) Execute() (*SimplifiedCDARResponse, *http.Response, error) {
	return r.ApiService.SubmitEncaisseeApiV1CdarEncaisseePostExecute(r)
}

/*
SubmitEncaisseeApiV1CdarEncaisseePost [Simplified] Submit PAID status (212) - Issued invoice

**Simplified endpoint for OD** - Submit a PAID status (212) for an **ISSUED** invoice.

This status is **mandatory for PPF** (BR-FR-CDV-14 requires the paid amount).

**Use case:** The **seller** confirms payment receipt for an invoice they issued.

**Who issues this status?**
- **Issuer (IssuerTradeParty):** The seller (SE = Seller) who received payment
- **Recipient (RecipientTradeParty):** The buyer (BY = Buyer) who paid

**Reference:** XP Z12-014 Annex B, example UC1_F202500003_07-CDV-212_Encaissee.xml

**Authentication:** JWT Bearer (recommended) or PDP credentials in request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitEncaisseeApiV1CdarEncaisseePostRequest
*/
func (a *Flux6InvoiceLifecycleCDARAPIService) SubmitEncaisseeApiV1CdarEncaisseePost(ctx context.Context) ApiSubmitEncaisseeApiV1CdarEncaisseePostRequest {
	return ApiSubmitEncaisseeApiV1CdarEncaisseePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimplifiedCDARResponse
func (a *Flux6InvoiceLifecycleCDARAPIService) SubmitEncaisseeApiV1CdarEncaisseePostExecute(r ApiSubmitEncaisseeApiV1CdarEncaisseePostRequest) (*SimplifiedCDARResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimplifiedCDARResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux6InvoiceLifecycleCDARAPIService.SubmitEncaisseeApiV1CdarEncaisseePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/encaissee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.encaisseeRequest == nil {
		return localVarReturnValue, nil, reportError("encaisseeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.encaisseeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitRefuseeApiV1CdarRefuseePostRequest struct {
	ctx context.Context
	ApiService *Flux6InvoiceLifecycleCDARAPIService
	refuseeRequest *RefuseeRequest
}

func (r ApiSubmitRefuseeApiV1CdarRefuseePostRequest) RefuseeRequest(refuseeRequest RefuseeRequest) ApiSubmitRefuseeApiV1CdarRefuseePostRequest {
	r.refuseeRequest = &refuseeRequest
	return r
}

func (r ApiSubmitRefuseeApiV1CdarRefuseePostRequest) Execute() (*SimplifiedCDARResponse, *http.Response, error) {
	return r.ApiService.SubmitRefuseeApiV1CdarRefuseePostExecute(r)
}

/*
SubmitRefuseeApiV1CdarRefuseePost [Simplified] Submit REFUSED status (210) - Received invoice

**Simplified endpoint for OD** - Submit a REFUSED status (210) for a **RECEIVED** invoice.

This status is **mandatory for PPF** (BR-FR-CDV-15 requires a reason code).

**Use case:** The **buyer** refuses an invoice they received.

**Who issues this status?**
- **Issuer (IssuerTradeParty):** The buyer (BY = Buyer) refusing the invoice
- **Recipient (RecipientTradeParty):** The seller (SE = Seller) who issued the invoice

**Reference:** XP Z12-014 Annex B, example UC3_F202500005_04-CDV-210_Refusee.xml

**Allowed reason codes (BR-FR-CDV-CL-09):**
- `TX_TVA_ERR`: Incorrect VAT rate
- `MONTANTTOTAL_ERR`: Incorrect total amount
- `CALCUL_ERR`: Calculation error
- `NON_CONFORME`: Non-compliant
- `DOUBLON`: Duplicate
- `DEST_ERR`: Wrong recipient
- `TRANSAC_INC`: Incomplete transaction
- `EMMET_INC`: Unknown issuer
- `CONTRAT_TERM`: Contract terminated
- `DOUBLE_FACT`: Double billing
- `CMD_ERR`: Order error
- `ADR_ERR`: Address error
- `REF_CT_ABSENT`: Missing contract reference

**Authentication:** JWT Bearer (recommended) or PDP credentials in request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitRefuseeApiV1CdarRefuseePostRequest
*/
func (a *Flux6InvoiceLifecycleCDARAPIService) SubmitRefuseeApiV1CdarRefuseePost(ctx context.Context) ApiSubmitRefuseeApiV1CdarRefuseePostRequest {
	return ApiSubmitRefuseeApiV1CdarRefuseePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimplifiedCDARResponse
func (a *Flux6InvoiceLifecycleCDARAPIService) SubmitRefuseeApiV1CdarRefuseePostExecute(r ApiSubmitRefuseeApiV1CdarRefuseePostRequest) (*SimplifiedCDARResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimplifiedCDARResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux6InvoiceLifecycleCDARAPIService.SubmitRefuseeApiV1CdarRefuseePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/refusee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.refuseeRequest == nil {
		return localVarReturnValue, nil, reportError("refuseeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.refuseeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateCdarApiV1CdarValidatePostRequest struct {
	ctx context.Context
	ApiService *Flux6InvoiceLifecycleCDARAPIService
	validateCDARRequest *ValidateCDARRequest
}

func (r ApiValidateCdarApiV1CdarValidatePostRequest) ValidateCDARRequest(validateCDARRequest ValidateCDARRequest) ApiValidateCdarApiV1CdarValidatePostRequest {
	r.validateCDARRequest = &validateCDARRequest
	return r
}

func (r ApiValidateCdarApiV1CdarValidatePostRequest) Execute() (*ValidateCDARResponse, *http.Response, error) {
	return r.ApiService.ValidateCdarApiV1CdarValidatePostExecute(r)
}

/*
ValidateCdarApiV1CdarValidatePost Validate CDAR structured data

Validate CDAR structured data without generating XML.

**Note:** This endpoint validates structured data fields only.
Use `/validate-xml` to validate a pre-generated CDAR XML file against XSD and Schematron.

Checks:
- Field formats (SIREN, dates, etc.)
- Enum codes (status, reason, action)
- Business rules BR-FR-CDV-*

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateCdarApiV1CdarValidatePostRequest
*/
func (a *Flux6InvoiceLifecycleCDARAPIService) ValidateCdarApiV1CdarValidatePost(ctx context.Context) ApiValidateCdarApiV1CdarValidatePostRequest {
	return ApiValidateCdarApiV1CdarValidatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ValidateCDARResponse
func (a *Flux6InvoiceLifecycleCDARAPIService) ValidateCdarApiV1CdarValidatePostExecute(r ApiValidateCdarApiV1CdarValidatePostRequest) (*ValidateCDARResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateCDARResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux6InvoiceLifecycleCDARAPIService.ValidateCdarApiV1CdarValidatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.validateCDARRequest == nil {
		return localVarReturnValue, nil, reportError("validateCDARRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validateCDARRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateXmlCdarApiV1CdarValidateXmlPostRequest struct {
	ctx context.Context
	ApiService *Flux6InvoiceLifecycleCDARAPIService
	xmlFile *os.File
}

// CDAR XML file to validate
func (r ApiValidateXmlCdarApiV1CdarValidateXmlPostRequest) XmlFile(xmlFile *os.File) ApiValidateXmlCdarApiV1CdarValidateXmlPostRequest {
	r.xmlFile = xmlFile
	return r
}

func (r ApiValidateXmlCdarApiV1CdarValidateXmlPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ValidateXmlCdarApiV1CdarValidateXmlPostExecute(r)
}

/*
ValidateXmlCdarApiV1CdarValidateXmlPost Validate CDAR XML against XSD and Schematron BR-FR-CDV

Validates a CDAR XML file against:

1. **XSD schema**: UN/CEFACT D22B CrossDomainAcknowledgementAndResponse
2. **Schematron BR-FR-CDV**: French business rules for invoice lifecycle

Returns validation status and detailed error messages if invalid.

**Note:** Use `/validate` to validate structured data fields (JSON).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateXmlCdarApiV1CdarValidateXmlPostRequest
*/
func (a *Flux6InvoiceLifecycleCDARAPIService) ValidateXmlCdarApiV1CdarValidateXmlPost(ctx context.Context) ApiValidateXmlCdarApiV1CdarValidateXmlPostRequest {
	return ApiValidateXmlCdarApiV1CdarValidateXmlPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *Flux6InvoiceLifecycleCDARAPIService) ValidateXmlCdarApiV1CdarValidateXmlPostExecute(r ApiValidateXmlCdarApiV1CdarValidateXmlPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "Flux6InvoiceLifecycleCDARAPIService.ValidateXmlCdarApiV1CdarValidateXmlPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/validate-xml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xmlFile == nil {
		return localVarReturnValue, nil, reportError("xmlFile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var xmlFileLocalVarFormFileName string
	var xmlFileLocalVarFileName     string
	var xmlFileLocalVarFileBytes    []byte

	xmlFileLocalVarFormFileName = "xml_file"
	xmlFileLocalVarFile := r.xmlFile

	if xmlFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(xmlFileLocalVarFile)

		xmlFileLocalVarFileBytes = fbs
		xmlFileLocalVarFileName = xmlFileLocalVarFile.Name()
		xmlFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: xmlFileLocalVarFileBytes, fileName: xmlFileLocalVarFileName, formFileName: xmlFileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
