/*
FactPulse REST API

 REST API for electronic invoicing in France: Factur-X, AFNOR PDP/PA, electronic signatures.  ## ðŸŽ¯ Main Features  ### ðŸ“„ Factur-X Invoice Generation - **Formats**: XML only or PDF/A-3 with embedded XML - **Profiles**: MINIMUM, BASIC, EN16931, EXTENDED - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **ðŸ†• Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### âœ… Validation and Compliance - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata, electronic signatures - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules) - **Asynchronous Processing**: Celery support for heavy validations (VeraPDF)  ### ðŸ“¡ AFNOR PDP/PA Integration (XP Z12-013) - **Flow Submission**: Send invoices to Partner Dematerialization Platforms - **Flow Search**: View submitted invoices - **Download**: Retrieve PDF/A-3 with XML - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user (stored credentials or zero-storage)  ### âœï¸ PDF Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification - **Certificate Generation**: Self-signed X.509 certificates for testing  ### ðŸ”„ Asynchronous Processing - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **No timeout**: Ideal for large files or heavy validations  ## ðŸ”’ Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### ðŸ”‘ Method 1: `/api/token/` API (Recommended)  **URL:** `https://factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - âœ… Full automation (CI/CD, scripts) - âœ… Programmatic token management - âœ… Refresh token support for automatic access renewal - âœ… Easy integration in any language/tool  #### ðŸ–¥ï¸ Method 2: Dashboard Generation (Alternative)  **URL:** https://factpulse.fr/api/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - âœ… Quick for API testing - âœ… No password required - âœ… Simple visual interface  **Disadvantages:** - âŒ Requires manual action - âŒ No refresh token - âŒ Less suited for automation  ### ðŸ“š Full Documentation  For more information on authentication and API usage: https://factpulse.fr/documentation-api/     

API version: 1.0.0
Contact: contact@factpulse.fr
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package factpulse

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// CDARCycleDeVieAPIService CDARCycleDeVieAPI service
type CDARCycleDeVieAPIService service

type ApiGenerateCdarApiV1CdarGeneratePostRequest struct {
	ctx context.Context
	ApiService *CDARCycleDeVieAPIService
	createCDARRequest *CreateCDARRequest
}

func (r ApiGenerateCdarApiV1CdarGeneratePostRequest) CreateCDARRequest(createCDARRequest CreateCDARRequest) ApiGenerateCdarApiV1CdarGeneratePostRequest {
	r.createCDARRequest = &createCDARRequest
	return r
}

func (r ApiGenerateCdarApiV1CdarGeneratePostRequest) Execute() (*GenerateCDARResponse, *http.Response, error) {
	return r.ApiService.GenerateCdarApiV1CdarGeneratePostExecute(r)
}

/*
GenerateCdarApiV1CdarGeneratePost GÃ©nÃ©rer un message CDAR

GÃ©nÃ¨re un message XML CDAR (Cross Domain Acknowledgement and Response)
pour communiquer le statut d'une facture.

**Types de messages:**
- **23** (Traitement): Message de cycle de vie standard
- **305** (Transmission): Message de transmission entre plateformes

**RÃ¨gles mÃ©tier:**
- BR-FR-CDV-14: Le statut 212 (ENCAISSEE) requiert un montant encaissÃ©
- BR-FR-CDV-15: Les statuts 206/207/208/210/213/501 requiÃ¨rent un code motif

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateCdarApiV1CdarGeneratePostRequest
*/
func (a *CDARCycleDeVieAPIService) GenerateCdarApiV1CdarGeneratePost(ctx context.Context) ApiGenerateCdarApiV1CdarGeneratePostRequest {
	return ApiGenerateCdarApiV1CdarGeneratePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GenerateCDARResponse
func (a *CDARCycleDeVieAPIService) GenerateCdarApiV1CdarGeneratePostExecute(r ApiGenerateCdarApiV1CdarGeneratePostRequest) (*GenerateCDARResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateCDARResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CDARCycleDeVieAPIService.GenerateCdarApiV1CdarGeneratePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/generate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCDARRequest == nil {
		return localVarReturnValue, nil, reportError("createCDARRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCDARRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActionCodesApiV1CdarActionCodesGetRequest struct {
	ctx context.Context
	ApiService *CDARCycleDeVieAPIService
}

func (r ApiGetActionCodesApiV1CdarActionCodesGetRequest) Execute() (*ActionCodesResponse, *http.Response, error) {
	return r.ApiService.GetActionCodesApiV1CdarActionCodesGetExecute(r)
}

/*
GetActionCodesApiV1CdarActionCodesGet Liste des codes action CDAR

Retourne la liste complÃ¨te des codes action (BR-FR-CDV-CL-10).

Ces codes indiquent l'action demandÃ©e sur la facture.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActionCodesApiV1CdarActionCodesGetRequest
*/
func (a *CDARCycleDeVieAPIService) GetActionCodesApiV1CdarActionCodesGet(ctx context.Context) ApiGetActionCodesApiV1CdarActionCodesGetRequest {
	return ApiGetActionCodesApiV1CdarActionCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActionCodesResponse
func (a *CDARCycleDeVieAPIService) GetActionCodesApiV1CdarActionCodesGetExecute(r ApiGetActionCodesApiV1CdarActionCodesGetRequest) (*ActionCodesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionCodesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CDARCycleDeVieAPIService.GetActionCodesApiV1CdarActionCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/action-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReasonCodesApiV1CdarReasonCodesGetRequest struct {
	ctx context.Context
	ApiService *CDARCycleDeVieAPIService
}

func (r ApiGetReasonCodesApiV1CdarReasonCodesGetRequest) Execute() (*ReasonCodesResponse, *http.Response, error) {
	return r.ApiService.GetReasonCodesApiV1CdarReasonCodesGetExecute(r)
}

/*
GetReasonCodesApiV1CdarReasonCodesGet Liste des codes motif CDAR

Retourne la liste complÃ¨te des codes motif de statut (BR-FR-CDV-CL-09).

Ces codes expliquent la raison d'un statut particulier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReasonCodesApiV1CdarReasonCodesGetRequest
*/
func (a *CDARCycleDeVieAPIService) GetReasonCodesApiV1CdarReasonCodesGet(ctx context.Context) ApiGetReasonCodesApiV1CdarReasonCodesGetRequest {
	return ApiGetReasonCodesApiV1CdarReasonCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReasonCodesResponse
func (a *CDARCycleDeVieAPIService) GetReasonCodesApiV1CdarReasonCodesGetExecute(r ApiGetReasonCodesApiV1CdarReasonCodesGetRequest) (*ReasonCodesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReasonCodesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CDARCycleDeVieAPIService.GetReasonCodesApiV1CdarReasonCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/reason-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStatusCodesApiV1CdarStatusCodesGetRequest struct {
	ctx context.Context
	ApiService *CDARCycleDeVieAPIService
}

func (r ApiGetStatusCodesApiV1CdarStatusCodesGetRequest) Execute() (*StatusCodesResponse, *http.Response, error) {
	return r.ApiService.GetStatusCodesApiV1CdarStatusCodesGetExecute(r)
}

/*
GetStatusCodesApiV1CdarStatusCodesGet Liste des codes statut CDAR

Retourne la liste complÃ¨te des codes statut de facture (BR-FR-CDV-CL-06).

Ces codes indiquent l'Ã©tat du cycle de vie d'une facture.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetStatusCodesApiV1CdarStatusCodesGetRequest
*/
func (a *CDARCycleDeVieAPIService) GetStatusCodesApiV1CdarStatusCodesGet(ctx context.Context) ApiGetStatusCodesApiV1CdarStatusCodesGetRequest {
	return ApiGetStatusCodesApiV1CdarStatusCodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StatusCodesResponse
func (a *CDARCycleDeVieAPIService) GetStatusCodesApiV1CdarStatusCodesGetExecute(r ApiGetStatusCodesApiV1CdarStatusCodesGetRequest) (*StatusCodesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatusCodesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CDARCycleDeVieAPIService.GetStatusCodesApiV1CdarStatusCodesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/status-codes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitCdarApiV1CdarSubmitPostRequest struct {
	ctx context.Context
	ApiService *CDARCycleDeVieAPIService
	userId *int32
	bodySubmitCdarApiV1CdarSubmitPost *BodySubmitCdarApiV1CdarSubmitPost
	jwtToken *string
	clientUid *string
}

func (r ApiSubmitCdarApiV1CdarSubmitPostRequest) UserId(userId int32) ApiSubmitCdarApiV1CdarSubmitPostRequest {
	r.userId = &userId
	return r
}

func (r ApiSubmitCdarApiV1CdarSubmitPostRequest) BodySubmitCdarApiV1CdarSubmitPost(bodySubmitCdarApiV1CdarSubmitPost BodySubmitCdarApiV1CdarSubmitPost) ApiSubmitCdarApiV1CdarSubmitPostRequest {
	r.bodySubmitCdarApiV1CdarSubmitPost = &bodySubmitCdarApiV1CdarSubmitPost
	return r
}

func (r ApiSubmitCdarApiV1CdarSubmitPostRequest) JwtToken(jwtToken string) ApiSubmitCdarApiV1CdarSubmitPostRequest {
	r.jwtToken = &jwtToken
	return r
}

func (r ApiSubmitCdarApiV1CdarSubmitPostRequest) ClientUid(clientUid string) ApiSubmitCdarApiV1CdarSubmitPostRequest {
	r.clientUid = &clientUid
	return r
}

func (r ApiSubmitCdarApiV1CdarSubmitPostRequest) Execute() (*SubmitCDARResponse, *http.Response, error) {
	return r.ApiService.SubmitCdarApiV1CdarSubmitPostExecute(r)
}

/*
SubmitCdarApiV1CdarSubmitPost GÃ©nÃ©rer et soumettre un message CDAR

GÃ©nÃ¨re un message CDAR et le soumet Ã  la plateforme PA/PDP.

NÃ©cessite une authentification AFNOR valide.

**Types de flux (flowType):**
- `CustomerInvoiceLC`: Cycle de vie cÃ´tÃ© client (acheteur)
- `SupplierInvoiceLC`: Cycle de vie cÃ´tÃ© fournisseur (vendeur)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitCdarApiV1CdarSubmitPostRequest
*/
func (a *CDARCycleDeVieAPIService) SubmitCdarApiV1CdarSubmitPost(ctx context.Context) ApiSubmitCdarApiV1CdarSubmitPostRequest {
	return ApiSubmitCdarApiV1CdarSubmitPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitCDARResponse
func (a *CDARCycleDeVieAPIService) SubmitCdarApiV1CdarSubmitPostExecute(r ApiSubmitCdarApiV1CdarSubmitPostRequest) (*SubmitCDARResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitCDARResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CDARCycleDeVieAPIService.SubmitCdarApiV1CdarSubmitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.bodySubmitCdarApiV1CdarSubmitPost == nil {
		return localVarReturnValue, nil, reportError("bodySubmitCdarApiV1CdarSubmitPost is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "form", "")
	if r.jwtToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jwt_token", r.jwtToken, "form", "")
	}
	if r.clientUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client_uid", r.clientUid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodySubmitCdarApiV1CdarSubmitPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest struct {
	ctx context.Context
	ApiService *CDARCycleDeVieAPIService
	userId *int32
	bodySubmitCdarXmlApiV1CdarSubmitXmlPost *BodySubmitCdarXmlApiV1CdarSubmitXmlPost
	jwtToken *string
	clientUid *string
}

func (r ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest) UserId(userId int32) ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest {
	r.userId = &userId
	return r
}

func (r ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest) BodySubmitCdarXmlApiV1CdarSubmitXmlPost(bodySubmitCdarXmlApiV1CdarSubmitXmlPost BodySubmitCdarXmlApiV1CdarSubmitXmlPost) ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest {
	r.bodySubmitCdarXmlApiV1CdarSubmitXmlPost = &bodySubmitCdarXmlApiV1CdarSubmitXmlPost
	return r
}

func (r ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest) JwtToken(jwtToken string) ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest {
	r.jwtToken = &jwtToken
	return r
}

func (r ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest) ClientUid(clientUid string) ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest {
	r.clientUid = &clientUid
	return r
}

func (r ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest) Execute() (*SubmitCDARResponse, *http.Response, error) {
	return r.ApiService.SubmitCdarXmlApiV1CdarSubmitXmlPostExecute(r)
}

/*
SubmitCdarXmlApiV1CdarSubmitXmlPost Soumettre un XML CDAR prÃ©-gÃ©nÃ©rÃ©

Soumet un message XML CDAR prÃ©-gÃ©nÃ©rÃ© Ã  la plateforme PA/PDP.

Utile pour soumettre des XML gÃ©nÃ©rÃ©s par d'autres systÃ¨mes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest
*/
func (a *CDARCycleDeVieAPIService) SubmitCdarXmlApiV1CdarSubmitXmlPost(ctx context.Context) ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest {
	return ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitCDARResponse
func (a *CDARCycleDeVieAPIService) SubmitCdarXmlApiV1CdarSubmitXmlPostExecute(r ApiSubmitCdarXmlApiV1CdarSubmitXmlPostRequest) (*SubmitCDARResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitCDARResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CDARCycleDeVieAPIService.SubmitCdarXmlApiV1CdarSubmitXmlPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/submit-xml"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.bodySubmitCdarXmlApiV1CdarSubmitXmlPost == nil {
		return localVarReturnValue, nil, reportError("bodySubmitCdarXmlApiV1CdarSubmitXmlPost is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "form", "")
	if r.jwtToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jwt_token", r.jwtToken, "form", "")
	}
	if r.clientUid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client_uid", r.clientUid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodySubmitCdarXmlApiV1CdarSubmitXmlPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateCdarApiV1CdarValidatePostRequest struct {
	ctx context.Context
	ApiService *CDARCycleDeVieAPIService
	validateCDARRequest *ValidateCDARRequest
}

func (r ApiValidateCdarApiV1CdarValidatePostRequest) ValidateCDARRequest(validateCDARRequest ValidateCDARRequest) ApiValidateCdarApiV1CdarValidatePostRequest {
	r.validateCDARRequest = &validateCDARRequest
	return r
}

func (r ApiValidateCdarApiV1CdarValidatePostRequest) Execute() (*ValidateCDARResponse, *http.Response, error) {
	return r.ApiService.ValidateCdarApiV1CdarValidatePostExecute(r)
}

/*
ValidateCdarApiV1CdarValidatePost Valider des donnÃ©es CDAR

Valide les donnÃ©es CDAR sans gÃ©nÃ©rer le XML.

VÃ©rifie:
- Les formats des champs (SIREN, dates, etc.)
- Les codes enums (statut, motif, action)
- Les rÃ¨gles mÃ©tier BR-FR-CDV-*

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateCdarApiV1CdarValidatePostRequest
*/
func (a *CDARCycleDeVieAPIService) ValidateCdarApiV1CdarValidatePost(ctx context.Context) ApiValidateCdarApiV1CdarValidatePostRequest {
	return ApiValidateCdarApiV1CdarValidatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ValidateCDARResponse
func (a *CDARCycleDeVieAPIService) ValidateCdarApiV1CdarValidatePostExecute(r ApiValidateCdarApiV1CdarValidatePostRequest) (*ValidateCDARResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateCDARResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CDARCycleDeVieAPIService.ValidateCdarApiV1CdarValidatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/cdar/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.validateCDARRequest == nil {
		return localVarReturnValue, nil, reportError("validateCDARRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.validateCDARRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v APIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
